library(copula)
#library(evd)
library(LaplacesDemon)
################################################################################
# "copula" parameter in mvdc() can be any one of the following:
#(01) galambosCopula(2)
#(02) huslerReissCopula(0.3)
#(03) tawnCopula(0.3)
#(04) tevCopula(0.3, df=2, df.fixed=TRUE)
#(05) amhCopula(1, dim=2)
#(06) gumbelCopula(1, dim=2)
#(07) claytonCopula(1, dim=2)
#(08) frankCopula(3, dim=2)
#(09) joeCopula(1, dim=2)
#(10) fgmCopula(c(0.2,-0.2,-0.4), dim=2)
#(11) plackettCopula(param=2)
#(12) normalCopula(0.5, dim=3)
#(13) tCopula(0.5, dim=2, dispstr="toep", df=2, df.fixed=TRUE)
# "margins" and "paramMargins" parameters in mdvc() can be any one of the following:
# e.g. norm as long as pnorm, dnorm, qnorm, rnorm are all available
#(01) frechet: list(loc=0, scale=1, shape=2)
#(02) pareto: list(alpha=2)
#(03) exp: list(rate=1)
#(04) gamma: list(shape=1)
#(05) laplace: list(location=0, scale=1)
#(06) halfnorm: list(scale=1)
#(07) beta: list(shape1=2, shape2=3)
#(08) norm: list(mean=0, sd=1)
margin_lst <- list(frechet=list(name="Frechet", params=c("shape")),
pareto=list(name="Pareto", params=c("alpha")),
exp=list(name="Exp", params=c("rate")),
gamma=list(name="Gamma", params=c("shape")),
laplace=list(name="laplace", params=c("location", "scale")),
halfnorm=list(name="HalfNorm", params=c("scale")),
beta=list(name="Beta", params=c("shape1", "shape2")),
norm=list(name="Norm", params=c("mean", "sd")))
# beware Norm(mu,sd) here NOT Norm(mu,sd^2)!
get_legend <- function(margins, paramMargins){
text.legend <- c()
for (i in 1:length(margins)){
mar <- margins[i]; par <- paramMargins[[i]]
dist <- margin_lst[[mar]]
params <- paste0(par[dist$params], collapse=",")
text.legend[i] <- paste0(dist$name, "(", params, ")")
}
paste0(text.legend, collapse="+")
}
################################################################################
size <- 10^7
seed <- 4002
p <- seq(0.999, 0.99999, 0.000001)
get_quantile <- function(Z, p) quantile(rowSums(Z), p)/rowSums(apply(Z, 2, quantile, p))
################################################################################
### Clayton Copula with theta=1 ###
################################################################################
margins1 <- c("frechet", "frechet")
paramMargins1 <- list(list(loc=0, scale=1, shape=2),
list(loc=0, scale=1, shape=2))
margins2 <- c("frechet", "frechet")
paramMargins2 <- list(list(loc=0, scale=1, shape=1),
list(loc=0, scale=1, shape=1))
margins3 <- c("frechet", "frechet")
paramMargins3 <- list(list(loc=0, scale=1, shape=0.5),
list(loc=0, scale=1, shape=0.5))
set.seed(seed)
Z1 <- rMvdc(size, mvdc(copula=claytonCopula(1, dim=length(margins1)), margins=margins1, paramMargins=paramMargins1))
?pareto
?rpareto
length(NA)
length(NULL)
library(R.utils)
?tryCatch
e <- simpleError("test error")
tryCatch(stop(e), error=function(e) {NA})
a <- tryCatch(stop(e), error=function(e) {NA})
length(a)
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
M_lst <- c(1e1, 1e2, 1e3); n <- 1e5
Sim_Asian <- function(n, M, S_0, K, r, sigma, T, theta){
delta_t <- T / M
Euler <- function(z, S_t, theta){
S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z
}
Milstein <- function(z, S_t, theta){
(Euler(z, S_t, theta) +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Exact <- function(z, S_t, theta=2){
S_t*exp((r - sigma^2/2)*delta_t + sigma*sqrt(delta_t)*z)
}
# Asian_call
S_Eul <- S_0; avg_Eul <- S_0 / (M+1)
S_Mil <- S_0; avg_Mil <- S_0 / (M+1)
if (theta == 2) {
S_Ext <- S_0; avg_Ext <- S_0 / (M+1)
} else {
S_Ext <- NA; avg_Ext <- NA
}
for (m in 1:M){
z <- rnorm(n)
S_Eul <- Euler(z, S_Eul, theta)
avg_Eul <- avg_Eul + S_Eul/(M+1)
S_Mil <- Milstein(z, S_Mil, theta)
avg_Mil <- avg_Mil + S_Mil/(M+1)
if (theta == 2){
S_Ext <- Exact(z, S_Ext, theta)
avg_Ext <- avg_Ext + S_Ext/(M+1)
}
}
list(Eul=list(price=S_Eul, payoff=exp(-r*T)*pmax(avg_Eul-K, 0)),
Mil=list(price=S_Mil, payoff=exp(-r*T)*pmax(avg_Mil-K, 0)),
Ext=list(price=S_Ext, payoff=exp(-r*T)*pmax(avg_Ext-K, 0)))
}
################################################################################
BS_results <- data.frame(M=M_lst, n=n, Asian_Eul=0,
Asian_Mil=0, Asian_Ext=0)
par(mfrow=c(1,2))
for (i in 1:length(M_lst)){
M <- M_lst[i]
set.seed(4002)
Asian_BS <- Sim_Asian(n, M, S_0, K, r, sigma, T, 2)
BS_results$Asian_Eul[i] <- mean(Asian_BS$Eul$payoff)
BS_results$Asian_Mil[i] <- mean(Asian_BS$Mil$payoff)
BS_results$Asian_Ext[i] <- mean(Asian_BS$Ext$payoff)
Eul_diff <- Asian_BS$Ext$price - Asian_BS$Eul$price
Mil_diff <- Asian_BS$Ext$price - Asian_BS$Mil$price
print(paste(diff(range(Eul_diff)), diff(range(Mil_diff)),
diff(range(Eul_diff))/diff(range(Mil_diff))))
hist(Eul_diff, xlim=c(-max(abs(Eul_diff)), max(abs(Eul_diff))),
xlab="Error", main="Euler Scheme")
hist(Mil_diff, xlim=c(-max(abs(Mil_diff)), max(abs(Mil_diff))),
xlab="Error", main="Milstein Scheme")
}
BS_results
################################################################################
M <- 1e3; n_lst <- c(1e3, 1e4, 1e5, 1e6)
BS_results <- data.frame(M=M_lst, n=n, Asian_Eul=0,
Asian_Mil=0, Asian_Ext=0)
par(mfrow=c(1,2))
for (i in 1:length(n_lst)){
n <- n_lst[i]
set.seed(4002)
Asian_BS <- Sim_Asian(n, M, S_0, K, r, sigma, T, 2)
BS_results$Asian_Eul[i] <- mean(Asian_BS$Eul$payoff)
BS_results$Asian_Mil[i] <- mean(Asian_BS$Mil$payoff)
BS_results$Asian_Ext[i] <- mean(Asian_BS$Ext$payoff)
Eul_diff <- Asian_BS$Ext$price - Asian_BS$Eul$price
Mil_diff <- Asian_BS$Ext$price - Asian_BS$Mil$price
print(paste(diff(range(Eul_diff)), diff(range(Mil_diff)),
diff(range(Eul_diff))/diff(range(Mil_diff))))
hist(Eul_diff, xlim=c(-max(abs(Eul_diff)), max(abs(Eul_diff))),
xlab="Error", main="Euler Scheme")
hist(Mil_diff, xlim=c(-max(abs(Mil_diff)), max(abs(Mil_diff))),
xlab="Error", main="Milstein Scheme")
}
M <- 1e3; n_lst <- c(1e3, 1e4, 1e5, 1e6)
BS_results <- data.frame(M=M, n=n_lst, Asian_Eul=0,
Asian_Mil=0, Asian_Ext=0)
par(mfrow=c(2,length(n_lst)))
for (i in 1:length(n_lst)){
n <- n_lst[i]
set.seed(4002)
Asian_BS <- Sim_Asian(n, M, S_0, K, r, sigma, T, 2)
BS_results$Asian_Eul[i] <- mean(Asian_BS$Eul$payoff)
BS_results$Asian_Mil[i] <- mean(Asian_BS$Mil$payoff)
BS_results$Asian_Ext[i] <- mean(Asian_BS$Ext$payoff)
Eul_diff <- Asian_BS$Ext$price - Asian_BS$Eul$price
Mil_diff <- Asian_BS$Ext$price - Asian_BS$Mil$price
print(paste(diff(range(Eul_diff)), diff(range(Mil_diff)),
diff(range(Eul_diff))/diff(range(Mil_diff))))
hist(Eul_diff, xlim=c(-max(abs(Eul_diff)), max(abs(Eul_diff))),
xlab="Error", main="Euler Scheme")
hist(Mil_diff, xlim=c(-max(abs(Mil_diff)), max(abs(Mil_diff))),
xlab="Error", main="Milstein Scheme")
}
BS_results
M <- 1e3; n_lst <- c(1e3, 1e4, 1e5, 1e6, 1e7)
BS_results <- data.frame(M=M, n=n_lst, Asian_Eul=0,
Asian_Mil=0, Asian_Ext=0)
par(mfcol=c(2,length(n_lst)))
for (i in 1:length(n_lst)){
n <- n_lst[i]
set.seed(4002)
Asian_BS <- Sim_Asian(n, M, S_0, K, r, sigma, T, 2)
BS_results$Asian_Eul[i] <- mean(Asian_BS$Eul$payoff)
BS_results$Asian_Mil[i] <- mean(Asian_BS$Mil$payoff)
BS_results$Asian_Ext[i] <- mean(Asian_BS$Ext$payoff)
Eul_diff <- Asian_BS$Ext$price - Asian_BS$Eul$price
Mil_diff <- Asian_BS$Ext$price - Asian_BS$Mil$price
print(paste(diff(range(Eul_diff)), diff(range(Mil_diff)),
diff(range(Eul_diff))/diff(range(Mil_diff))))
hist(Eul_diff, xlim=c(-max(abs(Eul_diff)), max(abs(Eul_diff))),
xlab="Error", main="Euler Scheme")
hist(Mil_diff, xlim=c(-max(abs(Mil_diff)), max(abs(Mil_diff))),
xlab="Error", main="Milstein Scheme")
}
BS_results
n_size <- seq(500, 100000, by=500)
length(n_size)
library(copula)
library(evd)              # frechet
library(LaplacesDemon)    # pareto, laplace, halfnorm
##################
size <- 2000
seed <- 4002
################################################################################
### Archimedean Copulae ###
################################################################################
par.old <- par()
par(mfrow=c(1,2), mar=c(2, 2, 2, 2))
################################################################################
set.seed(seed)
plot(rCopula(size, amhCopula(0.2, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, amhCopula(0.8, dim=2)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, claytonCopula(-0.5, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, claytonCopula(8, dim=2)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, frankCopula(2, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, frankCopula(8, dim=2)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, gumbelCopula(2, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, gumbelCopula(6, dim=2)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, joeCopula(2, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, joeCopula(6, dim=2)), col="blue", ylab="", xlab="")
################################################################################
### Extreme Value Copulae ###
################################################################################
set.seed(seed)
plot(rCopula(size, galambosCopula(2)), col="blue", ylab="", xlab="")
plot(rCopula(size, galambosCopula(8)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, huslerReissCopula(2)), col="blue", ylab="", xlab="")
plot(rCopula(size, huslerReissCopula(8)), col="blue", ylab="", xlab="")
?galambosCopula
set.seed(seed)
plot(rCopula(size, galambosCopula(2)), col="blue", ylab="", xlab="")
plot(rCopula(size, galambosCopula(6)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, galambosCopula(2)), col="blue", ylab="", xlab="")
plot(rCopula(size, galambosCopula(8)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, amhCopula(0.2, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, amhCopula(0.8, dim=2)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, amhCopula(0.2, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, amhCopula(0.9, dim=2)), col="blue", ylab="", xlab="")
set.seed(seed)
plot(rCopula(size, amhCopula(0.2, dim=2)), col="blue", ylab="", xlab="")
plot(rCopula(size, amhCopula(0.9, dim=2)), col="blue", ylab="", xlab="")
library(copula)
library(evd)              # frechet
library(LaplacesDemon)    # pareto, laplace, halfnorm
################################################################################
# "copula" parameter in mvdc() can be any one of the following:
#(01) galambosCopula(2)
#(02) huslerReissCopula(0.3)
#(03) tawnCopula(0.3)
#(04) tevCopula(0.3, df=2, df.fixed=TRUE)
#(05) amhCopula(1, dim=2)
#(06) gumbelCopula(1, dim=2)
#(07) claytonCopula(1, dim=2)
#(08) frankCopula(3, dim=2)
#(09) joeCopula(1, dim=2)
#(10) fgmCopula(c(0.2,-0.2,-0.4), dim=2)
#(11) plackettCopula(param=2)
#(12) normalCopula(0.5, dim=3)
#(13) tCopula(0.5, dim=2, dispstr="toep", df=2, df.fixed=TRUE)
# "margins" and "paramMargins" parameters in mdvc() can be any one of the following:
# e.g. norm as long as pnorm, dnorm, qnorm, rnorm are all available
#(01) frechet: list(loc=0, scale=1, shape=2)
#(02) pareto: list(alpha=2)
#(03) exp: list(rate=1)
#(04) gamma: list(shape=1)
#(05) laplace: list(location=0, scale=1)
#(06) halfnorm: list(scale=1)
#(07) beta: list(shape1=2, shape2=3)
#(08) norm: list(mean=0, sd=1)
margin_lst <- list(frechet=list(name="Frechet", params=c("shape")),
pareto=list(name="Pareto", params=c("alpha")),
exp=list(name="Exp", params=c("rate")),
gamma=list(name="Gamma", params=c("shape")),
laplace=list(name="laplace", params=c("location", "scale")),
halfnorm=list(name="HalfNorm", params=c("scale")),
beta=list(name="Beta", params=c("shape1", "shape2")),
norm=list(name="Norm", params=c("mean", "sd")))
# beware Norm(mu,sd) here NOT Norm(mu,sd^2)!
get_legend <- function(margins, paramMargins){
text.legend <- c()
for (i in 1:length(margins)){
mar <- margins[i]; par <- paramMargins[[i]]
dist <- margin_lst[[mar]]
params <- paste0(par[dist$params], collapse=",")
text.legend[i] <- paste0(dist$name, "(", params, ")")
}
paste0(text.legend, collapse="+")
}
################################################################################
size <- 10^7
seed <- 4002
p <- seq(0.999, 0.99999, 0.000001)
get_quantile <- function(Z, p) quantile(rowSums(Z), p)/rowSums(apply(Z, 2, quantile, p))
margins1 <- c("exp", "exp")
paramMargins1 <- list(list(rate=1),
list(rate=1))
margins2 <- c("halfnorm", "halfnorm")
paramMargins2 <- list(list(scale=1),
list(scale=1))
margins3 <- c("beta", "beta")
paramMargins3 <- list(list(shape1=2, shape2=3),
list(shape1=2, shape2=3))
set.seed(seed)
Z1 <- rMvdc(size, mvdc(copula=gumbelCopula(1.5, dim=length(margins1)), margins=margins1, paramMargins=paramMargins1))
Z2 <- rMvdc(size, mvdc(copula=gumbelCopula(1.5, dim=length(margins2)), margins=margins2, paramMargins=paramMargins2))
Z3 <- rMvdc(size, mvdc(copula=gumbelCopula(1.5, dim=length(margins3)), margins=margins3, paramMargins=paramMargins3))
plot(p, get_quantile(Z1, p), lty=1, type="l", col="blue", lwd=2,
ylim=c(0.9, 1.05), pch=16, xlab="p", ylab="V@R Ratio", cex.main=1)
lines(p, get_quantile(Z2, p), lty=2, type="l", col="black", lwd=2)
abline(h=c(1), lwd=1.5, lty=4, col="orange")
text.legend <- c(get_legend(margins1, paramMargins1), get_legend(margins2, paramMargins2))
legend("bottomleft", legend=text.legend, lty=1:2, col=c("blue", "black"), lwd=2, cex=1,
text.width=max(strwidth(text.legend))*1.2)
plot(p, get_quantile(Z3, p), lty=3, type="l", col="red", lwd=2,
ylim=c(0.9, 1.05), pch=16, xlab="p", ylab="V@R Ratio", cex.main=1)
abline(h=c(1), lwd=1.5, lty=4, col="orange")
text.legend <- c(get_legend(margins3, paramMargins3))
legend("bottomleft", legend=text.legend, lty=3, col=c("red"), lwd=2, cex=1,
text.width=max(strwidth(text.legend))*1.2)
plot(p, get_quantile(Z1, p), lty=1, type="l", col="blue", lwd=2,
ylim=c(0.9, 1.05), pch=16, xlab="p", ylab="V@R Ratio", cex.main=1)
lines(p, get_quantile(Z2, p), lty=2, type="l", col="black", lwd=2)
abline(h=c(1), lwd=1.5, lty=4, col="orange")
text.legend <- c(get_legend(margins1, paramMargins1), get_legend(margins2, paramMargins2))
legend("bottomleft", legend=text.legend, lty=1:2, col=c("blue", "black"), lwd=2, cex=1,
text.width=max(strwidth(text.legend))*1.2)
plot(p, get_quantile(Z3, p), lty=3, type="l", col="red", lwd=2,
ylim=c(0.9, 1.05), pch=16, xlab="p", ylab="V@R Ratio", cex.main=1)
abline(h=c(1), lwd=1.5, lty=4, col="orange")
text.legend <- c(get_legend(margins3, paramMargins3))
legend("bottomleft", legend=text.legend, lty=3, col=c("red"), lwd=2, cex=1,
text.width=max(strwidth(text.legend))*1.2)
?quantile
library(discretization)
install.packages("discretization")
library(discretization)
data(iris)
mdlp(iris)$Disc.data
X <- iris[,c(1,2,3,4)]
X
MDLP(X)
mdlp(X)
mdlp(iris)
mdlp(iris)
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
library(tseries)
d <- read.csv("../Datasets/stock_1999_2002.csv", row.names=1)
date <- as.Date(rownames(d), format="%d/%m/%Y")
d <- as.ts(d)
u <- (lag(d) - d)/d
colnames(u) <- paste0(colnames(d), "_Return")
################################################################################
library(xts)
u1 <- u[,"HSBC_Return"]; u2 <- u[,"CLP_Return"]; u3 <- u[,"CK_Return"]
s_HSBC_90 <- xts(rollapply(u1, 90, sd), order.by=date[-c(1:90)])
s_HSBC_180 <- xts(rollapply(u1, 180, sd), order.by=date[-c(1:180)])
plot(s_HSBC_90, col="blue", type="l", lwd=2,
main="Simple moving standard deviation of HSBC")
lines(s_HSBC_180, col="red", type="l", lwd=2)
addLegend("topright", legend.names=c("s_90", "s_180"),
col=c("blue", "red"), lwd=2)
################################################################################
round(min(s_HSBC_90), 5); round(max(s_HSBC_90), 5)
sqrt(252) * min(s_HSBC_90); sqrt(252) * max(s_HSBC_90)
round(min(s_HSBC_180), 5); round(max(s_HSBC_180), 5)
sqrt(252) * min(s_HSBC_180); sqrt(252) * max(s_HSBC_180)
################################################################################
library(fGarch) # load library "fGarch"
# GARCH(1,1) on HSBC return
res_HSBC <- garchFit(~garch(1, 1), data=u1, include.mean=FALSE)
round(coef(res_HSBC), 6)  # display coefficient in 6 digits
res_HSBC@fit$llh          # compute negative log-likelihood value
res_HSBC@fit$matcoef
################################################################################
omega <- coef(res_HSBC)[1]; alpha <- coef(res_HSBC)[2]; beta <- coef(res_HSBC)[3]
omega / (1 - alpha - beta)
################################################################################
GARCH_11 <- function(para, u){
u <- as.numeric(u)
omega0 <- para[1]
alpha <- para[2]
beta <- para[3]
nu <- var(u)
#nu <- omega0/(1-alpha-beta)
loglik <- dnorm(u[1], 0, sqrt(nu), log=TRUE)
for (i in 2:length(u)){
nu <- omega0 + alpha*u[i-1]^2 + beta*nu
loglik <- loglik + dnorm(u[i], 0, sqrt(nu), log=TRUE)
}
return(-loglik)
}
para <- c(0.3,0.1,0.4)
self_model <- constrOptim(para, GARCH_11, grad=NULL, u=u1,
method="Nelder-Mead",
ui=rbind(c(0,-1,-1), diag(3), -cbind(0, diag(2))),
ci=c(-1, rep(0, 3), rep(-1, 2))
)
self_model$par
self_model$value      # negative log-likelihood
################################################################################
omega <- coef(res_HSBC)[1]
alpha <- coef(res_HSBC)[2]
beta <- coef(res_HSBC)[3]
# initialize u_0^2 and nu_0 being mean of u_i^2
nu <- omega + alpha*mean(u1**2) + beta*mean(u1**2) # nu_1
for (i in 2:length(u1)){
nu <- c(nu, omega + alpha*u1[i-1]^2 + beta*nu[i-1])
}
all.equal(as.vector(nu), res_HSBC@h.t)
resid_HSBC <- as.vector(u1/sqrt(nu))  # u1/sqrt(res_HSBC@h.t)
all.equal(resid_HSBC, residuals(res_HSBC, standardize=TRUE))
Box.test(u1^2, lag=15, type="Ljung")
Box.test(resid_HSBC^2, lag=15, type="Ljung")
par(mfrow=c(2,2), mar=c(4,4,3,3))
plot(res_HSBC, which=c(2, 5, 11, 13))
################################################################################
par(mfrow=c(1,1))
vol_HSBC <- xts(sqrt(res_HSBC@h.t), order.by=date[-1])
plot(vol_HSBC, col="green", lwd=2, ylab="", type="l",
ylim=c(0.01, 0.04), xaxt="n", main="HSBC volatilities")
lines(s_HSBC_90, col="blue", lwd=2)
lines(s_HSBC_180, col="red", lwd=2)
addLegend("topleft", legend.names=c("nu", "s_90", "s_180"),
col=c("green", "blue", "red"), lwd=2)
################################################################################
u[dim(u)[1],]
cor(u[(dim(u)[1]-89):dim(u)[1],])
var(u[(dim(u)[1]-89):dim(u)[1],])
################################################################################
res_HSBC <- garchFit(~garch(1, 1), data=u1, include.mean=FALSE)
res_CLP <- garchFit(~garch(1, 1), data=u2, include.mean=FALSE)
res_CK <- garchFit(~garch(1, 1), data=u3, include.mean=FALSE)
(coef <- rbind(coef(res_HSBC), coef(res_CLP), coef(res_CK)))
round(colMeans(coef), 6) # compute the column mean
################################################################################
# test <- garchFit(~garch(1, 1), data=u1, include.mean=FALSE, cond.dist="std")
# plot(test, which=13)
# coef(test)
################################################################################
library(rugarch)
gjr_mean_model <- list(armaOrder=c(0,0), include.mean=FALSE)
gjr_var_model <- list(model="gjrGARCH", garchOrder=c(1,1))
gjr_spec <- ugarchspec(mean.model=gjr_mean_model,
variance.model=gjr_var_model,
distribution.model="norm")
gjr_HSBC <- ugarchfit(data=u1, spec=gjr_spec)
gjr_CLP <- ugarchfit(data=u2, spec=gjr_spec)
gjr_CK <- ugarchfit(data=u3, spec=gjr_spec)
gjr_param <- rbind(coef(gjr_HSBC), coef(gjr_CLP), coef(gjr_CK))
colnames(gjr_param) <- c("omega", "alpha", "beta", "theta")
rownames(gjr_param) <- c("HSBC", "CLP", "CK")
gjr_param
################################################################################
omega <- coef(gjr_HSBC)[1]
alpha <- coef(gjr_HSBC)[2]
beta <- coef(gjr_HSBC)[3]
theta <- coef(gjr_HSBC)[4]
# initialize nu_0 being mean of u_i^2
nu <- mean(u1^2) # nu_1
for (i in 2:length(u1)){
nu <- c(nu, omega + alpha*u1[i-1]^2 + beta*nu[i-1] +
theta*u1[i-1]^2*(u1[i-1] < 0))
}
all.equal(sqrt(as.vector(nu)), gjr_HSBC@fit$sigma)
resid_HSBC <- as.vector(u1/sqrt(nu))  # u1/gjr_HSBC@fit$sigma
gjr_resid_HSBC <- as.numeric(residuals(gjr_HSBC, standardize=TRUE))
all.equal(resid_HSBC, gjr_resid_HSBC)
Box.test(gjr_resid_HSBC^2, lag=15, type="Ljung")
gjr_resid_CLP <- as.numeric(residuals(gjr_CLP, standardize=TRUE))
Box.test(gjr_resid_CLP^2, lag=15, type="Ljung")
gjr_resid_CK <- as.numeric(residuals(gjr_CK, standardize=TRUE))
Box.test(gjr_resid_CK^2, lag=15, type="Ljung")
par(mfrow=c(2,2), mar=c(4,4,3,3))
plot(gjr_HSBC@fit$sigma, type="l")
acf(gjr_resid_HSBC)
acf(gjr_resid_HSBC^2)
plot(gjr_HSBC, which=9)
Box.test(gjr_resid_HSBC, lag=15, type="Ljung")
gjr_resid_CLP <- as.numeric(residuals(gjr_CLP, standardize=TRUE))
Box.test(gjr_resid_CLP, lag=15, type="Ljung")
gjr_resid_CK <- as.numeric(residuals(gjr_CK, standardize=TRUE))
Box.test(gjr_resid_CK, lag=15, type="Ljung")
plot.rugarch
qqnorm(gjr_resid_HSBC)
qqline()
qqline(gjr_resid_HSBC)
Box.test(gjr_resid_HSBC, lag=30, type="Ljung")
Box.test(gjr_resid_HSBC, lag=100, type="Ljung")
Box.test(gjr_resid_HSBC, lag=400, type="Ljung")
ks.test(gjr_resid_HSBC)
ks.test(gjr_resid_HSBC, "norm")
shapiro.test(gjr_resid_HSBC)
par(mfrow=c(1,3), mar=c(4,4,3,3))
plot(gjr_HSBC@fit$sigma, type="l")
acf(gjr_resid_HSBC)
acf(gjr_resid_HSBC^2)
mean(gjr_resid_HSBC)
sd(gjr_resid_HSBC)
shapiro.test((gjr_resid_HSBC - mean(gjr_resid_HSBC))/sd(gjr_resid_HSBC))
