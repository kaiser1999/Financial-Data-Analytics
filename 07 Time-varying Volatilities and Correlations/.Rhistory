log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
phi <- mu_phi; psi <- mu_psi; lamb <- beta_lamb/(alpha_lamb + 1)
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
phi <- mu_phi; psi <- mu_psi; lamb <- beta_lamb/(alpha_lamb + 1)
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
sqrt(0.00012761)
.12^2
logV
y
################################################################################
### Finite Difference ###
################################################################################
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
Sim_greek <- function(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta, seed=4002){
delta_t <- T / M
Milstein <- function(z, S_t, r, sigma){
(S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Euro_call <- function(S_t, K, r, sigma, T){
set.seed(seed)
for (m in 1:M){
z <- rnorm(n)
S_t <- Milstein(z, S_t, r, sigma)
}
mean(exp(-r*T) * pmax(S_t - K, 0))
}
Y <- Euro_call(S_0, K, r, sigma, T)
# Estimate delta using forward and central difference method
Y_S0_neg <- Euro_call(S_0-h_d, K, r, sigma, T)
Y_S0_pos <- Euro_call(S_0+h_d, K, r, sigma, T)
# Estimate vega using forward and central difference method
Y_sig_neg <- Euro_call(S_0, K, r, sigma-h_v, T)
Y_sig_pos <- Euro_call(S_0, K, r, sigma+h_v, T)
list(delta=list(forward=(Y_S0_pos - Y)/h_d,
central=(Y_S0_pos - Y_S0_neg)/(2*h_d)),
vega=list(forward=(Y_sig_pos - Y)/h_v,
central=(Y_sig_pos - Y_sig_neg)/(2*h_v)))
}
################################################################################
# Compute the exact delta and vega for theta=2 (BS)
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
h_delta <- seq(0.5, 0.05, by=-0.05); h_vega <- seq(0.05, 0.005, by=-0.005)
n <- 1e5; M <- 1e3
theta_lst <- c(2, 1, 1.8)
for (theta in theta_lst){
results_delta <- data.frame(h=h_delta, theta=theta,
delta_forward=0, delta_central=0)
results_vega <- data.frame(h=h_vega, theta=theta,
vega_forward=0, vega_central=0)
prog_bar <- txtProgressBar(min=0, max=length(h_delta), width=50, style=3)
for (i in 1:length(h_delta)) {
h_d <- h_delta[i]; h_v <- h_vega[i]
Euro_CEV <- Sim_greek(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta=theta)
results_delta$delta_forward[i] <- Euro_CEV$delta$forward
results_delta$delta_central[i] <- Euro_CEV$delta$central
results_vega$vega_forward[i] <- Euro_CEV$vega$forward
results_vega$vega_central[i] <- Euro_CEV$vega$central
setTxtProgressBar(prog_bar, i)
}
cat("\n")
print(results_delta)
print(results_vega)
}
h_delta <- seq(0.5, 0.05, by=-0.05); h_vega <- seq(0.05, 0.005, by=-0.005)
n <- 1e5; M <- 1e4
theta_lst <- c(2, 1, 1.8)
for (theta in theta_lst){
results_delta <- data.frame(h=h_delta, theta=theta,
delta_forward=0, delta_central=0)
results_vega <- data.frame(h=h_vega, theta=theta,
vega_forward=0, vega_central=0)
prog_bar <- txtProgressBar(min=0, max=length(h_delta), width=50, style=3)
for (i in 1:length(h_delta)) {
h_d <- h_delta[i]; h_v <- h_vega[i]
Euro_CEV <- Sim_greek(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta=theta)
results_delta$delta_forward[i] <- Euro_CEV$delta$forward
results_delta$delta_central[i] <- Euro_CEV$delta$central
results_vega$vega_forward[i] <- Euro_CEV$vega$forward
results_vega$vega_central[i] <- Euro_CEV$vega$central
setTxtProgressBar(prog_bar, i)
}
cat("\n")
print(results_delta)
print(results_vega)
}
install.packages("R.utils")
# try several values of K, choose K so that stat. is maximized
kmstat <- function(X, K){
km <- kmeans(X, K)              # K-means clustering
ng <- km$size                   # size of each cluster
n <- nrow(X)                    # sample size
wcss <- sum(km$withinss)        # within group ss
bcss <- km$betweenss            # between group ss
# km$cluster: the cluster to which each point is allocated
out <- list((n-K)*bcss/((K-1)*wcss), ng, km$cluster)
names(out) <- c("stat", "size", "cluster")
return(out)
}
################################################################################
# Try kmeans(X, K) several times and output the best trial
km <- function(X, K, trial=5) {
res0 <- kmstat(X, K)            # result of the first trial
r0 <- res0$stat                 # stat from the first trial
for (i in 2:trial) {
res <- kmstat(X, K)           # new trial
if (res$stat > r0) {          # update r0 & res if it is better
r0 <- res$stat
res0 <- res
}
}
cat("cluster size=", res0$size, "\n") # cluster size
cat("stat=", res0$stat, "\n")         # display stat
return(res0$cluster)                  # cluster label
}
for (K in 2:25){
print(K)
km(X_train, K)
}
library(keras)        # MNIST dataset
library(nnet)
# Load MNIST dataset
mnist <- dataset_mnist()
X_train <- mnist$train$x
y_train <- mnist$train$y
X_test <- mnist$test$x
y_test <- mnist$test$y
X_train <- matrix(X_train, nrow=length(y_train))
X_test <- matrix(X_test, nrow=length(y_test))
for (K in 2:25){
print(K)
km(X_train, K)
}
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
library(tseries)
d <- read.csv("../Datasets/stock_1999_2002.csv", row.names=1)
date <- as.Date(rownames(d), format="%d/%m/%Y")
d <- as.ts(d)
u <- (lag(d) - d)/d
colnames(u) <- paste0(colnames(d), "_Return")
################################################################################
library(xts)
u1 <- u[,"HSBC_Return"]; u2 <- u[,"CLP_Return"]; u3 <- u[,"CK_Return"]
s_HSBC_90 <- xts(rollapply(u1, 90, sd), order.by=date[-c(1:90)])
s_HSBC_180 <- xts(rollapply(u1, 180, sd), order.by=date[-c(1:180)])
plot(s_HSBC_90, col="blue", type="l", lwd=2,
main="Simple moving standard deviation of HSBC")
lines(s_HSBC_180, col="red", type="l", lwd=2)
addLegend("topright", legend.names=c("s_90", "s_180"),
col=c("blue", "red"), lwd=2)
################################################################################
round(min(s_HSBC_90), 5); round(max(s_HSBC_90), 5)
sqrt(252) * min(s_HSBC_90); sqrt(252) * max(s_HSBC_90)
round(min(s_HSBC_180), 5); round(max(s_HSBC_180), 5)
sqrt(252) * min(s_HSBC_180); sqrt(252) * max(s_HSBC_180)
################################################################################
library(fGarch) # load library "fGarch"
# GARCH(1,1) on HSBC return
res_HSBC <- garchFit(~garch(1, 1), data=u1, include.mean=FALSE)
round(coef(res_HSBC), 6)  # display coefficient in 6 digits
res_HSBC@fit$llh          # compute log-likelihood value
res_HSBC@fit$matcoef
################################################################################
GARCH_11 <- function(para, u){
u <- as.numeric(u)
omega0 <- para[1]
alpha <- para[2]
beta <- para[3]
nu <- var(u)
#nu <- omega0/(1-alpha-beta)
loglik <- dnorm(u[1], 0, sqrt(nu), log=TRUE)
for (i in 2:length(u)){
nu <- omega0 + alpha*u[i-1]^2 + beta*nu
loglik <- loglik + dnorm(u[i], 0, sqrt(nu), log=TRUE)
}
return(-loglik)
}
para <- c(0.3,0.1,0.4)
model1 <- optim(para, fn=GARCH_11, gr=NULL, u=u1,
method="L-BFGS-B", lower=0, upper=c(Inf, 1, 1))
model1 <- optim(para, fn=GARCH_11, gr=NULL, u=u1,
method="L-BFGS-B", lower=rep(0, 3), upper=c(Inf, 1, 1))
model1 <- optim(para, fn=GARCH_11, gr=NULL, u=u1,
method="L-BFGS-B", lower=rep(0, 3), upper=c(10, 1, 1))
model1 <- optim(para, fn=GARCH_11, gr=NULL, u=u1,
method="L-BFGS-B", lower=rep(0, 3), upper=c(10, 1, 1),
control = list(trace = 5,fnscale=-1))
model1$par
model1 <- optim(para, fn=GARCH_11, gr=NULL, u=u1,
method="L-BFGS-B", lower=rep(0, 3), upper=c(Inf, 1, 1),
control = list(trace = 5,fnscale=-1))
self_model <- constrOptim(para, GARCH_11, grad=NULL, u=u1,
method="BFGS",
ui=rbind(c(0,-1,-1), diag(3), -cbind(0, diag(2))),
ci=c(-1, rep(0, 3), rep(-1, 2))
)
para
?constrOptim
self_model <- constrOptim(para, GARCH_11, grad=NULL, u=u1,
method="Nelder-Mead",
ui=rbind(c(0,-1,-1), diag(3), -cbind(0, diag(2))),
ci=c(-1, rep(0, 3), rep(-1, 2))
)
self_model <- constrOptim(para, GARCH_11, grad=NULL, u=u1,
method="Nelder-Mead",
ui=rbind(c(0,-1,-1), diag(3), -cbind(0, diag(2))),
ci=c(-1, rep(0, 3), rep(-1, 2))
)
self_model <- constrOptim(para, GARCH_11, grad=NULL, u=u1,
method="BFGS",
ui=rbind(c(0,-1,-1), diag(3), -cbind(0, diag(2))),
ci=c(-1, rep(0, 3), rep(-1, 2))
)
self_model <- constrOptim(para, GARCH_11, grad=NULL, u=u1,
method="BFGS",
ui=rbind(c(0,-1,-1), diag(3), -cbind(0, diag(2))),
ci=c(-1, rep(0, 3), rep(-1, 2), hessian=T)
)
para <- c(0.3,0.1,0.4)
self_model <- constrOptim(para, GARCH_11, grad=NULL, u=u1,
method="Nelder-Mead",
ui=rbind(c(0,-1,-1), diag(3), -cbind(0, diag(2))),
ci=c(-1, rep(0, 3), rep(-1, 2))
)
self_model$par
################################################################################
omega <- coef(res_HSBC)[1]
alpha <- coef(res_HSBC)[2]
beta <- coef(res_HSBC)[3]
# initialize u_0^2 and nu_0 being mean of u_i^2
nu <- omega + alpha*mean(u1**2) + beta*mean(u1**2) # nu_1
for (i in 2:length(u1)){
nu <- c(nu, omega + alpha*u1[i-1]^2 + beta*nu[i-1])
}
all.equal(as.vector(nu), res_HSBC@h.t)
resid_HSBC <- as.vector(u1/sqrt(nu))  # u1/sqrt(res_HSBC@h.t)
all.equal(resid_HSBC, residuals(res_HSBC, standardize=TRUE))
Box.test(u1^2, lag=15, type="Ljung")
Box.test(resid_HSBC^2, lag=15, type="Ljung")
par(mfrow=c(2,2), mar=c(4,4,3,3))
plot(res_HSBC, which=c(2, 5, 11, 13))
################################################################################
par(mfrow=c(1,1))
vol_HSBC <- xts(sqrt(res_HSBC@h.t), order.by=date[-1])
plot(vol_HSBC, col="green", lwd=2, ylab="", type="l",
ylim=c(0.01, 0.04), xaxt="n", main="HSBC volatilities")
lines(s_HSBC_90, col="blue", lwd=2)
lines(s_HSBC_180, col="red", lwd=2)
addLegend("topleft", legend.names=c("nu", "s_90", "s_180"),
col=c("green", "blue", "red"), lwd=2)
library(rugarch)
gjr_mean_model <- list(armaOrder=c(0,0), include.mean=FALSE)
gjr_var_model <- list(model="gjrGARCH", garchOrder=c(1,1))
gjr_spec <- ugarchspec(mean.model=gjr_mean_model,
variance.model=gjr_var_model,
distribution.model="norm")
gjr_HSBC <- ugarchfit(data=u1, spec=gjr_spec)
gjr_CLP <- ugarchfit(data=u2, spec=gjr_spec)
gjr_CK <- ugarchfit(data=u3, spec=gjr_spec)
gjr_param <- rbind(coef(gjr_HSBC), coef(gjr_CLP), coef(gjr_CK))
colnames(gjr_param) <- c("omega", "alpha", "beta", "theta")
rownames(gjr_param) <- c("HSBC", "CLP", "CK")
gjr_param
omega <- coef(gjr_HSBC)[1]
alpha <- coef(gjr_HSBC)[2]
beta <- coef(gjr_HSBC)[3]
theta <- coef(gjr_HSBC)[4]
# initialize nu_0 being mean of u_i^2
nu <- mean(u1^2) # nu_1
for (i in 2:length(u1)){
nu <- c(nu, omega + alpha*u1[i-1]^2 + beta*nu[i-1] +
theta*u1[i-1]^2*(u1[i-1] < 0))
}
all.equal(sqrt(as.vector(nu)), gjr_HSBC@fit$sigma)
nu <- mean(u1^2) # nu_1
nu
nu[1]
sqrt(as.vector(nu))
gjr_HSBC@fit$sigma
gjr_HSBC@fit$coef
gjr_HSBC@fit$kappa()
gjr_HSBC@fit$kappa
gjr_HSBC@fit$solver
gjr_param
