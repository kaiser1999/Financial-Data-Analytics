for (i in 1:length(n_size)){
theta <- 2
delta_pathwise[i] <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
}
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
seed = 4002
y_t <- 1; v_0 <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- y_t * (1 + r*delta_t + sigma*theta/2*S_t^(theta/2-1)*dw_t)
v_t <- v_t * (1 + r*delta_t + S_t^(theta/2-1)*(S_t + sigma*theta/2*dw_t))
S_t <- S_t * (1 + r*delta_t + sigma*S_t^(theta/2-1)*dw_t)
}
delta_t <- T / M
y_t <- 1; v_t <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- y_t * (1 + r*delta_t + sigma*theta/2*S_t^(theta/2-1)*dw_t)
v_t <- v_t * (1 + r*delta_t + S_t^(theta/2-1)*(S_t + sigma*theta/2*dw_t))
S_t <- S_t * (1 + r*delta_t + sigma*S_t^(theta/2-1)*dw_t)
}
mean(exp(-r*T)*(S_t > K) * y_t)
mean(exp(-r*T)*(S_t > K) * v_t)
y_t <- 1; v_t <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- y_t * (1 + r*delta_t + sigma*theta/2*S_t^(theta/2-1)*dw_t)
v_t <- v_t + r*v_t*delta_t + S_t^(theta/2-1)*(S_t + sigma*theta/2*v_t*dw_t)
S_t <- S_t * (1 + r*delta_t + sigma*S_t^(theta/2-1)*dw_t)
}
mean(exp(-r*T)*(S_t > K) * y_t)
mean(exp(-r*T)*(S_t > K) * v_t)
y_t <- 1; v_t <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- y_t * (1 + r*delta_t + sigma*theta/2*S_t^(theta/2-1)*dw_t)
v_t <- v_t + r*v_t*delta_t + S_t^(theta/2-1)*(S_t + sigma*theta/2*v_t)*dw_t
S_t <- S_t * (1 + r*delta_t + sigma*S_t^(theta/2-1)*dw_t)
}
mean(exp(-r*T)*(S_t > K) * y_t)
mean(exp(-r*T)*(S_t > K) * v_t)
exact_vega
greek_pathwise <- function(n, M, S_0, K, r, sigma, T, theta, seed=4002){
delta_t <- T / M
y_t <- 1; v_t <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- y_t + r*y_t*delta_t + sigma*theta/2*S_t^(theta/2-1)*y_t*dw_t
v_t <- v_t + r*v_t*delta_t + S_t^(theta/2-1)*(S_t + sigma*theta/2*v_t)*dw_t
S_t <- S_t + r*S_t*delta_t + sigma*S_t^(theta/2)*dw_t
}
list(delta=mean(exp(-r*T)*(S_t > K) * y_t),
vega=mean(exp(-r*T)*(S_t > K) * v_t))
}
delta_pathwise <- c(); vega_pathwise <- c()
for (i in 1:length(n_size)){
theta <- 2
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
# Plot the graph of estimated Vega and exact Vega
plot(n_size, vega_pathwise, type="o", col="red", ylim=c(1, 4),
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
lines(n_size, vega_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
M <- 1e3; theta <- 1.8
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
plot(n_size, vega_pathwise, type="o", col="red", ylim=c(1, 4),
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
################################################################################
M <- 1e3; theta <- 1
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
plot(n_size, vega_pathwise, type="o", col="red", ylim=c(1, 4),
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
set.seed(4002)
n_size <- seq(400, 30000, by=400)
delta_pathwise <- c(); vega_pathwise <- c()
delta_likelihood <- c(); vega_likelihood <- c()
mu <- (r-sigma^2/2)*T
# Estimate delta and vega with different n
for (i in 1:length(n_size)) {
# Generate the Black-Scholes sample
w_T <- sqrt(T) * rnorm(n_size[i])
S_T <- S_0 * exp(mu + sigma * w_T)
d_payoff <- exp(-r * T) * (S_T > K)
# Estimate delta and vega using pathwise differentiation method
delta_pathwise[i] <- mean(d_payoff * S_T/S_0)
vega_pathwise[i] <- mean(d_payoff * S_T*(w_T - sigma*T))
payoff <- exp(-r * T) * pmax(S_T - K, 0)
# Estimate delta and vega using likelihood ratio method
delta_likelihood[i] <- mean(payoff * w_T/(S_0*sigma*T))
vega_likelihood[i] <- mean(payoff * ((w_T^2/T - 1)/sigma - w_T))
}
# Plot the graph of estimated delta and exact delta
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
lines(n_size, delta_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
# Plot the graph of estimated vega and exact vega
plot(n_size, vega_pathwise, type="o", col="red", ylim=c(1, 4),
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
lines(n_size, vega_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
################################################################################
### CEV ###
################################################################################
greek_pathwise <- function(n, M, S_0, K, r, sigma, T, theta, seed=4002){
delta_t <- T / M
y_t <- 1; v_t <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- y_t + r*y_t*delta_t + sigma*theta/2*S_t^(theta/2-1)*y_t*dw_t
v_t <- v_t + r*v_t*delta_t + S_t^(theta/2-1)*(S_t + sigma*theta/2*v_t)*dw_t
S_t <- S_t + r*S_t*delta_t + sigma*S_t^(theta/2)*dw_t
}
list(delta=mean(exp(-r*T)*(S_t > K) * y_t),
vega=mean(exp(-r*T)*(S_t > K) * v_t))
}
################################################################################
M <- 1e3; theta <- 2
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
################################################################################
M <- 1e3; theta <- 1.8
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
################################################################################
M <- 1e3; theta <- 1
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
v_t <- (v_t + r*v_t*delta_t
+ S_t^(theta/2-1)*(S_t + sigma*theta/2*v_t)*dw_t)
y_t <- (y_t + r*y_t*delta_t
+ sigma*theta/2*S_t^(theta/2-1)*y_t*dw_t)
M <- 1e3; theta <- 2
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "exact"), pch=c(21, NA))
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "exact"), pch=c(21, NA))
seq(500, 100000, by=500)
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
################################################################################
### Black-scholes ###
################################################################################
set.seed(4002)
n_size <- seq(500, 100000, by=500)
delta_pathwise <- c(); vega_pathwise <- c()
delta_likelihood <- c(); vega_likelihood <- c()
mu <- (r-sigma^2/2)*T
# Estimate delta and vega with different n
for (i in 1:length(n_size)) {
# Generate the Black-Scholes sample
w_T <- sqrt(T) * rnorm(n_size[i])
S_T <- S_0 * exp(mu + sigma * w_T)
d_payoff <- exp(-r * T) * (S_T > K)
# Estimate delta and vega using pathwise differentiation method
delta_pathwise[i] <- mean(d_payoff * S_T/S_0)
vega_pathwise[i] <- mean(d_payoff * S_T*(w_T - sigma*T))
payoff <- exp(-r * T) * pmax(S_T - K, 0)
# Estimate delta and vega using likelihood ratio method
delta_likelihood[i] <- mean(payoff * w_T/(S_0*sigma*T))
vega_likelihood[i] <- mean(payoff * ((w_T^2/T - 1)/sigma - w_T))
}
# Plot the graph of estimated delta and exact delta
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
lines(n_size, delta_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
# Plot the graph of estimated vega and exact vega
plot(n_size, vega_pathwise, type="o", col="red", ylim=c(1, 4),
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
lines(n_size, vega_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
################################################################################
### CEV ###
################################################################################
greek_pathwise <- function(n, M, S_0, K, r, sigma, T, theta, seed=4002){
delta_t <- T / M
y_t <- 1; v_t <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- (y_t + r*y_t*delta_t
+ sigma*theta/2*S_t^(theta/2-1)*y_t*dw_t)
v_t <- (v_t + r*v_t*delta_t
+ S_t^(theta/2-1)*(S_t + sigma*theta/2*v_t)*dw_t)
S_t <- S_t + r*S_t*delta_t + sigma*S_t^(theta/2)*dw_t
}
list(delta=mean(exp(-r*T)*(S_t > K) * y_t),
vega=mean(exp(-r*T)*(S_t > K) * v_t))
}
################################################################################
M <- 1e4; theta <- 2
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
set.seed(4002)
n_size <- seq(500, 100000, by=500)
delta_pathwise <- c(); vega_pathwise <- c()
delta_likelihood <- c(); vega_likelihood <- c()
mu <- (r-sigma^2/2)*T
# Estimate delta and vega with different n
for (i in 1:length(n_size)) {
# Generate the Black-Scholes sample
w_T <- sqrt(T) * rnorm(n_size[i])
S_T <- S_0 * exp(mu + sigma * w_T)
d_payoff <- exp(-r * T) * (S_T > K)
# Estimate delta and vega using pathwise differentiation method
delta_pathwise[i] <- mean(d_payoff * S_T/S_0)
vega_pathwise[i] <- mean(d_payoff * S_T*(w_T - sigma*T))
payoff <- exp(-r * T) * pmax(S_T - K, 0)
# Estimate delta and vega using likelihood ratio method
delta_likelihood[i] <- mean(payoff * w_T/(S_0*sigma*T))
vega_likelihood[i] <- mean(payoff * ((w_T^2/T - 1)/sigma - w_T))
}
# Plot the graph of estimated delta and exact delta
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
lines(n_size, delta_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
# Plot the graph of estimated vega and exact vega
plot(n_size, vega_pathwise, type="o", col="red", ylim=c(0.8, 4.1),
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
lines(n_size, vega_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
################################################################################
### CEV ###
################################################################################
greek_pathwise <- function(n, M, S_0, K, r, sigma, T, theta, seed=4002){
delta_t <- T / M
y_t <- 1; v_t <- 0; S_t <- S_0
set.seed(seed)
for (m in 1:M){
dw_t <- sqrt(delta_t) * rnorm(n)
y_t <- (y_t + r*y_t*delta_t
+ sigma*theta/2*S_t^(theta/2-1)*y_t*dw_t)
v_t <- (v_t + r*v_t*delta_t
+ S_t^(theta/2-1)*(S_t + sigma*theta/2*v_t)*dw_t)
S_t <- S_t + r*S_t*delta_t + sigma*S_t^(theta/2)*dw_t
}
list(delta=mean(exp(-r*T)*(S_t > K) * y_t),
vega=mean(exp(-r*T)*(S_t > K) * v_t))
}
################################################################################
n_size <- seq(500, 100000, by=500)
M <- 1e4; theta <- 2
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "exact"), pch=c(21, NA))
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "exact"), pch=c(21, NA))
################################################################################
theta <- 1.8
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
################################################################################
theta <- 1
delta_pathwise <- c(); vega_pathwise <- c()
# Estimate delta with different n
for (i in 1:length(n_size)){
Euro_CEV <- greek_pathwise(n_size[i], M, S_0, K, r, sigma, T, theta)
delta_pathwise[i] <- Euro_CEV$delta
vega_pathwise[i] <- Euro_CEV$vega
}
plot(n_size, delta_pathwise, type="o", col="red",
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
plot(n_size, vega_pathwise, type="o", col="red",
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
################################################################################
### Black-scholes ###
################################################################################
set.seed(4002)
n_size <- seq(500, 100000, by=500)
delta_pathwise <- c(); vega_pathwise <- c()
delta_likelihood <- c(); vega_likelihood <- c()
mu <- (r-sigma^2/2)*T
# Estimate delta and vega with different n
for (i in 1:length(n_size)) {
# Generate the Black-Scholes sample
w_T <- sqrt(T) * rnorm(n_size[i])
S_T <- S_0 * exp(mu + sigma * w_T)
d_payoff <- exp(-r * T) * (S_T > K)
# Estimate delta and vega using pathwise differentiation method
delta_pathwise[i] <- mean(d_payoff * S_T/S_0)
vega_pathwise[i] <- mean(d_payoff * S_T*(w_T - sigma*T))
payoff <- exp(-r * T) * pmax(S_T - K, 0)
# Estimate delta and vega using likelihood ratio method
delta_likelihood[i] <- mean(payoff * w_T/(S_0*sigma*T))
vega_likelihood[i] <- mean(payoff * ((w_T^2/T - 1)/sigma - w_T))
}
# Plot the graph of estimated delta and exact delta
plot(n_size, delta_pathwise, type="o", col="red", ylim=c(0.8, 0.93),
xlab="number of paths", ylab="delta", main="", lwd=1.5, pch=21)
lines(n_size, delta_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
# Plot the graph of estimated vega and exact vega
plot(n_size, vega_pathwise, type="o", col="red", ylim=c(0.8, 4.1),
xlab="number of paths", ylab="vega", main="", lwd=1.5, pch=21)
lines(n_size, vega_likelihood, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise differentiation", "likelihood ratio",
"exact"), pch=c(21, 21, NA))
library(benford.analysis)     # US Census (2010) dataset
library(stringr)              # Pad leading zero
data(census.2000_2010)        # load census dataset
write.csv(census.2000_2010, file="../Datasets/census_2000_2010.csv")
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
write.csv(census.2000_2010, file="../Datasets/census_2000_2010.csv")
FT_1 <- substr(census_2010, 1, 1)       # Get first digit
census_2010 <- census.2000_2010$pop.2010
FT_1 <- substr(census_2010, 1, 1)       # Get first digit
Count_1 <- table(as.numeric(FT_1))      # A summary table
DIGITS_1 <- 1:9               # Possible first digit values
EP_1 <- log10(1 + 1/DIGITS_1)           # Expected proportion
Benford_Analysis(Count_1, EP_1, DIGITS_1, "FIRST DIGIT")
Benford_Analysis <- function(Count, EP, DIGITS, x_label=""){
# Fill in missing digits with zero
if(length(setdiff(DIGITS, as.numeric(names(Count)))) > 0) {
missing_digit <- setdiff(DIGITS, as.numeric(names(Count)))
Count[as.character(missing_digit)] <- 0
Count <- Count[order(as.numeric(names(Count)))]
}
# Remove any additional digit in Count not in the group DIGITS
if(length(setdiff(as.numeric(names(Count)), DIGITS)) > 0) {
Count <- Count[as.character(DIGITS)]
}
AP <- as.numeric(Count/sum(Count))
N <- sum(Count)
folded_z <- abs(AP - EP)/sqrt(EP*(1-EP)/N)
p_val <- 2*dnorm(folded_z)    # p-values for folded z-scores
print(DIGITS[p_val < 0.05])   # Rejected digits by Benford's law
# Build a bar chart for each digit
col <- rep("burlywood1", length(DIGITS))
col[p_val < 0.05] <- "red"
bar_name <- str_pad(DIGITS, nchar(tail(DIGITS, 1)), pad="0")
census.barplot <- barplot(AP, names.arg=bar_name, col=col, border=NA,
ylab="PROPORTION", xlab=x_label)
lines(census.barplot, EP, col="blue", lwd=2)
legend("top", ncol=3, c("Actual", "Rejected", "Benford's Law"),
lty=c(0,0,1), lwd=c(0,0,2), fill=c("burlywood1", "red", 0),
border=NA, col=c(0, 0, "blue"))
# Return the p-value of chi-squared goodness-of-fit test statistics
return(dchisq(sum(N*(AP - EP)^2/EP), length(DIGITS)-1))
}
################################################################################
FT_1 <- substr(census_2010, 1, 1)       # Get first digit
Count_1 <- table(as.numeric(FT_1))      # A summary table
DIGITS_1 <- 1:9               # Possible first digit values
EP_1 <- log10(1 + 1/DIGITS_1)           # Expected proportion
Benford_Analysis(Count_1, EP_1, DIGITS_1, "FIRST DIGIT")
FT_2 <- substr(census_2010, 2, 2)       # Get second digit
Count_2 <- table(as.numeric(FT_2))      # A summary table
DIGITS_2 <- 0:9               # Possible second digit values
EP_2 <- rep(0, length(DIGITS_2))        # Expected proportion
for (i in 1:9){
EP_2 <- EP_2 + log10(1 + 1/((10 * i + 0):(10 * i + 9)))
}
Benford_Analysis(Count_2, EP_2, DIGITS_2, "SECOND DIGIT")
FT_3 <- substr(census_2010, 1, 2)       # Get first-two digits
Count_3 <- table(as.numeric(FT_3))      # A summary table
DIGITS_3 <- 10:99             # Possible first-two digits values
EP_3 <- log10(1 + 1/DIGITS_3)           # Expected proportion
Benford_Analysis(Count_3, EP_3, DIGITS_3, "FIRST-TWO DIGITS")
FT_4 <- substr(census_2010, 1, 3)       # Get first-three digits
Count_4 <- table(as.numeric(FT_4))      # A summary table
DIGITS_4 <- 100:999           # Possible first-three digits values
EP_4 <- log10(1 + 1/DIGITS_4)           # Expected proportion
Benford_Analysis(Count_4, EP_4, DIGITS_4, "FIRST-THREE DIGITS")
FT_4
census_4_digit <- census_2010[nchar(census_2010) >= 4]
census_4_digit
table(nchar(census_2010))               # Table for digit length
table(nchar(census_2010))               # Table for digit length
census_4_digit <- census_2010[nchar(census_2010) >= 4]
FT_5 <- substr(census_4_digit, nchar(census_4_digit)-2+1,
nchar(census_4_digit))   # Get last-two digits
Count_5 <- table(as.numeric(FT_5))      # A summary table
DIGITS_5 <- 0:99              # Possible last-two digits values
EP_5 <- rep(1/length(DIGITS_5), length(DIGITS_5)) # EP
Benford_Analysis(Count_5, EP_5, DIGITS_5, "LAST-TWO DIGITS")
