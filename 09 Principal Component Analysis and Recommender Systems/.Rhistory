MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
phi <- mu_phi; psi <- mu_psi; lamb <- beta_lamb/(alpha_lamb + 1)
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
phi <- mu_phi; psi <- mu_psi; lamb <- beta_lamb/(alpha_lamb + 1)
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
sqrt(0.00012761)
.12^2
logV
y
################################################################################
### Finite Difference ###
################################################################################
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
Sim_greek <- function(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta, seed=4002){
delta_t <- T / M
Milstein <- function(z, S_t, r, sigma){
(S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Euro_call <- function(S_t, K, r, sigma, T){
set.seed(seed)
for (m in 1:M){
z <- rnorm(n)
S_t <- Milstein(z, S_t, r, sigma)
}
mean(exp(-r*T) * pmax(S_t - K, 0))
}
Y <- Euro_call(S_0, K, r, sigma, T)
# Estimate delta using forward and central difference method
Y_S0_neg <- Euro_call(S_0-h_d, K, r, sigma, T)
Y_S0_pos <- Euro_call(S_0+h_d, K, r, sigma, T)
# Estimate vega using forward and central difference method
Y_sig_neg <- Euro_call(S_0, K, r, sigma-h_v, T)
Y_sig_pos <- Euro_call(S_0, K, r, sigma+h_v, T)
list(delta=list(forward=(Y_S0_pos - Y)/h_d,
central=(Y_S0_pos - Y_S0_neg)/(2*h_d)),
vega=list(forward=(Y_sig_pos - Y)/h_v,
central=(Y_sig_pos - Y_sig_neg)/(2*h_v)))
}
################################################################################
# Compute the exact delta and vega for theta=2 (BS)
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
h_delta <- seq(0.5, 0.05, by=-0.05); h_vega <- seq(0.05, 0.005, by=-0.005)
n <- 1e5; M <- 1e3
theta_lst <- c(2, 1, 1.8)
for (theta in theta_lst){
results_delta <- data.frame(h=h_delta, theta=theta,
delta_forward=0, delta_central=0)
results_vega <- data.frame(h=h_vega, theta=theta,
vega_forward=0, vega_central=0)
prog_bar <- txtProgressBar(min=0, max=length(h_delta), width=50, style=3)
for (i in 1:length(h_delta)) {
h_d <- h_delta[i]; h_v <- h_vega[i]
Euro_CEV <- Sim_greek(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta=theta)
results_delta$delta_forward[i] <- Euro_CEV$delta$forward
results_delta$delta_central[i] <- Euro_CEV$delta$central
results_vega$vega_forward[i] <- Euro_CEV$vega$forward
results_vega$vega_central[i] <- Euro_CEV$vega$central
setTxtProgressBar(prog_bar, i)
}
cat("\n")
print(results_delta)
print(results_vega)
}
h_delta <- seq(0.5, 0.05, by=-0.05); h_vega <- seq(0.05, 0.005, by=-0.005)
n <- 1e5; M <- 1e4
theta_lst <- c(2, 1, 1.8)
for (theta in theta_lst){
results_delta <- data.frame(h=h_delta, theta=theta,
delta_forward=0, delta_central=0)
results_vega <- data.frame(h=h_vega, theta=theta,
vega_forward=0, vega_central=0)
prog_bar <- txtProgressBar(min=0, max=length(h_delta), width=50, style=3)
for (i in 1:length(h_delta)) {
h_d <- h_delta[i]; h_v <- h_vega[i]
Euro_CEV <- Sim_greek(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta=theta)
results_delta$delta_forward[i] <- Euro_CEV$delta$forward
results_delta$delta_central[i] <- Euro_CEV$delta$central
results_vega$vega_forward[i] <- Euro_CEV$vega$forward
results_vega$vega_central[i] <- Euro_CEV$vega$central
setTxtProgressBar(prog_bar, i)
}
cat("\n")
print(results_delta)
print(results_vega)
}
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
library(pixmap)
SUB_FOLDERS <- paste0("s", 1:40)
train_img <- c()
test_img <- c()
for (sub_folder in SUB_FOLDERS) {
path <- file.path("../Datasets/ATT", sub_folder)
files <- list.files(path)
for (i in 1:length(files)) {
img_array <- read.pnm(file=file.path(path, files[i]))
# matching python arrays
rescale_array <- as.vector(t(img_array@grey) * 255)
if (i == 1) {
test_img <- cbind(test_img, rescale_array)
} else {
train_img <- cbind(train_img, rescale_array)
}
}
}
dim(train_img)
n <- ncol(train_img)
mu_train <- apply(train_img, 1, mean)
std_train <- apply(train_img, 1, sd) * sqrt((N-1)/N)
n <- ncol(train_img)
mu_train <- apply(train_img, 1, mean)
std_train <- apply(train_img, 1, sd) * sqrt((n-1)/n)
length(mu_train)
train_img - mu_train
A = train_img - mu_train
B = sweep(train_img, 1, mu_train, FUN="-")
A == B
A = sweep(sweep(train_img, 1, mu_train, FUN="-"),
1, std_train, FUN="/")
B = (train_img - mu_train) / std_train
A == B
sum(A == B)
rescale_train <- (train_img - mu_train) / std_train
rescale_test <- (test_img - mu_train) / std_train
# method 1: using eigen
eig <- eigen(t(rescale_train) %*% rescale_train / n)
lamb <- eig$values; H <- t(eig$vectors) %*% t(rescale_train)
H <- H / sqrt(rowSums(H^2))     # normalize each eigenvector
dim(H)
sum(lamb)
CumSum_s2 <- cumsum(lamb) / sum(lamb)
idx <- which(CumSum_s2 > 0.9)[1]
tilde_H <- H[1:idx,]
dim(tilde_H)
pca <- prcomp(t(rescale_train), center=FALSE, scale=FALSE)
idx <- which(cumsum(pca$sdev^2)/sum(pca$sdev^2) > 0.9)[1]
tilde_H[1,1:10]
pca$rotation[1,1:10]
pca$rotation[1:10,1]
A = pca$rotation[1:idx,]
sum(A == tilde_H)
dim(A)
dim(tilde_H)
dim(pca$rotation)
tilde_H <- t(pca$rotation[1,1:idx])
dim(tilde_H)
tilde_H <- t(pca$rotation[,1:idx])
dim(tilde_H)
i = 1
distance <- sqrt(colSums(score_train - score_test[,i])^2)
score_train <- tilde_H %*% rescale_train
score_test <- tilde_H %*% rescale_test
pred_dist <- c()
img_arr <- function(img){
t(apply(matrix(img, nrow=112, ncol=92, byrow=TRUE), 2, rev))
}
distance <- sqrt(colSums(score_train - score_test[,i])^2)
distance
length(distance)
distance <- sqrt(colSums(sweep(score_train, 2, score_test[,i]))^2)
distance <- sqrt(colSums(sweep(score_train, 1, score_test[,i]))^2)
distance
tilde_H[1,1:10]
sqrt(colSums((score_train - score_test[,i])^2))
nrow <- 8; ncol <- 10
par(mfrow=c(nrow, ncol), plt=c(0.05,0.95,0,0.7), oma=c(1,1,1,1))
for (i in 1:ncol(score_test)) {
distance <- sqrt(colSums((score_train - score_test[,i])^2))
idx_train <- which.min(distance)
image(img_arr(test_img[,i]), col=grey(seq(0, 1, length=256)),
xaxt='n', yaxt='n')
title("Test image", font.main=1 , line=1)
image(img_arr(train_img[,idx_train]), col=grey(seq(0, 1, length=256)),
xaxt='n', yaxt='n')
title(paste("Distance", round(distance[idx_train], 2)), font.main=1, line=1)
pred_dist <- c(pred_dist, distance[idx_train])
}
col <- rep("blue", ncol(score_test))
col[35] <- "red"
barplot(pred_dist, col=col)
################################################################################
par(mfrow=c(1, 1))
################################################################################
par(mfrow=c(1, 1))
col <- rep("blue", ncol(score_test))
col[35] <- "red"
barplot(pred_dist, col=col)
?hline
abline(h=65, type=2)
abline(h=65, lty=2)
par(mfrow=c(1, 1))
col <- rep("blue", ncol(score_test))
col[35] <- "red"
barplot(pred_dist, col=col)
abline(h=65, lty=2)
par(mfrow=c(1, 1))
col <- rep("blue", ncol(score_test))
col[35] <- "red"
barplot(pred_dist, col=col, xlab="Index", ylab="Distance")
abline(h=65, lty=2)
dev.off()
par(opar)
opar <- par()
par(opar)
col <- rep("blue", ncol(score_test))
col[35] <- "red"
barplot(pred_dist, col=col, xlab="Index", ylab="Distance")
abline(h=65, lty=2)
col <- rep("blue", n_test)
n_test <- ncol(score_test)
col <- rep("blue", n_test)
col[35] <- "red"
barplot(pred_dist, names=1:n_test, col=col, xlab="Index", ylab="Distance")
abline(h=65, lty=2)
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
library(pixmap)
SUB_FOLDERS <- paste0("s", 1:40)
train_img <- c()
test_img <- c()
for (sub_folder in SUB_FOLDERS) {
path <- file.path("../Datasets/ATT", sub_folder)
files <- list.files(path)
for (i in 1:length(files)) {
img_array <- read.pnm(file=file.path(path, files[i]))
# matching python arrays
rescale_array <- as.vector(t(img_array@grey) * 255)
if (i == 1) {
test_img <- cbind(test_img, rescale_array)
} else {
train_img <- cbind(train_img, rescale_array)
}
}
}
n <- ncol(train_img)
mu_train <- apply(train_img, 1, mean)
std_train <- apply(train_img, 1, sd) * sqrt((n-1)/n)
rescale_train <- (train_img - mu_train) / std_train
rescale_test <- (test_img - mu_train) / std_train
################################################################################
# method 1: using eigen
eig <- eigen(t(rescale_train) %*% rescale_train / n)
lamb <- eig$values; H <- t(eig$vectors) %*% t(rescale_train)
H <- H / sqrt(rowSums(H^2))     # normalize each eigenvector
dim(H)                          # a n x (hw) matrix
sum(lamb)
CumSum_s2 <- cumsum(lamb) / sum(lamb)
idx <- which(CumSum_s2 > 0.9)[1]
tilde_H <- H[1:idx,]
dim(tilde_H)                    # m x (hw) matrix
################################################################################
# method 2: using prcomp with the already normalized training faces
pca <- prcomp(t(rescale_train), center=FALSE, scale=FALSE)
idx <- which(cumsum(pca$sdev^2)/sum(pca$sdev^2) > 0.9)[1]
tilde_H <- t(pca$rotation[,1:idx])
dim(tilde_H)                    # m x (hw) matrix
################################################################################
score_train <- tilde_H %*% rescale_train    # m x n matrix
score_test <- tilde_H %*% rescale_test      # m x n matrix
pred_dist <- c()
n_test <- ncol(score_test)
img_arr <- function(img){
t(apply(matrix(img, nrow=112, ncol=92, byrow=TRUE), 2, rev))
}
nrow <- 8; ncol <- 10
opar <- par()
par(mfrow=c(nrow, ncol), plt=c(0.05,0.95,0,0.7), oma=c(1,1,1,1))
for (i in 1:n_test) {
distance <- sqrt(colSums((score_train - score_test[,i])^2))
idx_train <- which.min(distance)
image(img_arr(test_img[,i]), col=grey(seq(0, 1, length=256)),
xaxt='n', yaxt='n')
title("Test image", font.main=1 , line=1)
image(img_arr(train_img[,idx_train]), col=grey(seq(0, 1, length=256)),
xaxt='n', yaxt='n')
title(paste("Distance", round(distance[idx_train], 2)), font.main=1, line=1)
pred_dist <- c(pred_dist, distance[idx_train])
}
################################################################################
par(opar)
col <- rep("blue", n_test)
col[35] <- "red"
barplot(pred_dist, names=1:n_test, col=col, xlab="Index", ylab="Distance")
abline(h=65, lty=2)
barplot(pred_dist, names=1:n_test, col=col, ylim=c(0, 80),
xlab="Index", ylab="Distance")
abline(h=65, lty=2)
par(mfrow=c(nrow, ncol), plt=c(0.05,0.95,0,0.7), oma=c(1,1,1,1))
for (i in 1:n_test) {
distance <- sqrt(colSums((score_train - score_test[,i])^2))
idx_train <- which.min(distance)
image(img_arr(test_img[,i]), col=grey(seq(0, 1, length=256)),
xaxt='n', yaxt='n')
title("Test image", font.main=1 , line=1)
image(img_arr(train_img[,idx_train]), col=grey(seq(0, 1, length=256)),
xaxt='n', yaxt='n')
title(paste("Distance", round(distance[idx_train], 3)), font.main=1, line=1)
pred_dist <- c(pred_dist, distance[idx_train])
}
