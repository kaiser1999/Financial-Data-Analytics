hist(Mil_diff, xlim=c(-max(abs(Mil_diff)), max(abs(Mil_diff))),
xlab="Error", main="Milstein Scheme")
Eul_diff
range(Eul_diff)
Q
q2
q
sort(Asian_theta$Eul$price)
qqplot(q, Eul_diff); qqline(Eul_diff, datax=q)
abline(lm(q, Eul_diff))
?lm
qqplot(q, sort(Asian_theta$Eul$price))
abline(lm(q, sort(Asian_theta$Eul$price)))
?ls
abline(ls(q, sort(Asian_theta$Eul$price)))
abline(lsfit(q, sort(Asian_theta$Eul$price)))
qqplot(q, sort(Asian_theta$Mil$price))
abline(lsfit(q, sort(Asian_theta$Mil$price)))
qqplot(q, sort(Asian_theta$Eul$price), ylab="Sample quantiles")
abline(lsfit(q, sort(Asian_theta$Eul$price)))
qqplot(q, sort(Asian_theta$Mil$price), ylab="Sample quantiles")
abline(lsfit(q, sort(Asian_theta$Mil$price)))
par(mfrow=c(1,2))
qqplot(q, sort(Asian_theta$Eul$price), ylab="Sample quantiles")
abline(lsfit(q, sort(Asian_theta$Eul$price)))
qqplot(q, sort(Asian_theta$Mil$price), ylab="Sample quantiles")
abline(lsfit(q, sort(Asian_theta$Mil$price)))
gc()
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
M_lst <- c(50, 100, 150); n <- 5e4
Sim_call <- function(n, M, S_0, K, r, sigma, T, theta,
type_call=Asian_call){
delta_t <- T / M
Euler <- function(z, S_t, theta){
S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z
}
Milstein <- function(z, S_t, theta){
(Euler(z, S_t, theta) +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Exact <- function(z, S_t, theta=2){
S_t*exp((r - sigma^2/2)*delta_t + sigma*sqrt(delta_t)*z)
}
Asian_call <- function(z, method, theta=2){
S_t <- S_0
avg_St <- S_0 / (M+1)
for (m in 1:M){
S_t <- method(z[m,], S_t, theta)
avg_St <- avg_St + S_t/(M+1)
}
list(price=S_t, payoff=mean(exp(-r*T) * pmax(avg_St - K, 0)))
}
z <- matrix(rnorm(n * M), nrow=M)
Eul <- type_call(z, Euler, theta)
Mil <- type_call(z, Milstein, theta)
if (theta == 2){
Ext <- type_call(z, Exact, 2)
list(Eul=Eul, Mil=Mil, Ext=Ext)
}else{
list(Eul=Eul, Mil=Mil, Ext=NA)
}
}
Sim_Milstein <- function(n, M, S_0, K, r, sigma, T, theta){
delta_t <- T / M; S_t <- S_0
for (m in 1:M){
z <- rnorm(n)
S_t <- (S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z
+ sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
S_t
}
################################################################################
BS_results <- data.frame(M=M_lst, n=n, theta=2,
Asian_Eul=0, Asian_Mil=0, Asian_Ext=0)
par(mfrow=c(1,2))
set.seed(4002)
for (i in 1:length(M_lst)){
M <- M_lst[i]
Asian_BS <- Sim_call(n, M, S_0, K, r, sigma, T, 2)
BS_results$Asian_Eul[i] <- Asian_BS$Eul$payoff
BS_results$Asian_Mil[i] <- Asian_BS$Mil$payoff
BS_results$Asian_Ext[i] <- Asian_BS$Ext$payoff
Eul_diff <- Asian_BS$Ext$price - Asian_BS$Eul$price
Mil_diff <- Asian_BS$Ext$price - Asian_BS$Mil$price
hist(Eul_diff, xlim=c(-max(abs(Eul_diff)), max(abs(Eul_diff))),
xlab="Error", main="Euler Scheme")
hist(Mil_diff, xlim=c(-max(abs(Mil_diff)), max(abs(Mil_diff))),
xlab="Error", main="Milstein Scheme")
}
BS_results
################################################################################
theta <- 1
CEV_results <- data.frame(M=M_lst, n=n, theta=theta,
Asian_Eul=0, Asian_Mil=0, Asian_Ext=0)
set.seed(4002)
bootstrapped <- Sim_Milstein(1e6, 1e4, S_0, K, r, sigma, T, theta)
i <- ((1:n) - 0.5)/n
q <- quantile(bootstrapped, probs=i, type=4, names=FALSE)
for (i in 1:length(M_lst)){
M <- M_lst[i]
Asian_theta <- Sim_call(n, M, S_0, K, r, sigma, T, theta)
CEV_results$Asian_Eul[i] <- Asian_theta$Eul$payoff
CEV_results$Asian_Mil[i] <- Asian_theta$Mil$payoff
qqplot(q, sort(Asian_theta$Eul$price),
ylab="Sample quantiles", main="Euler scheme")
abline(lsfit(q, sort(Asian_theta$Eul$price)))
qqplot(q, sort(Asian_theta$Mil$price),
ylab="Sample quantiles", main="Milstein scheme")
abline(lsfit(q, sort(Asian_theta$Mil$price)))
}
CEV_results
################################################################################
theta <- 1.8
CEV_results <- data.frame(M=M_lst, n=n, theta=theta,
Asian_Eul=0, Asian_Mil=0)
set.seed(4002)
bootstrapped <- Sim_Milstein(1e6, 1e4, S_0, K, r, sigma, T, theta)
i <- ((1:n) - 0.5)/n
q <- quantile(bootstrapped, probs=i, type=4, names=FALSE)
for (i in 1:length(M_lst)){
M <- M_lst[i]
Asian_theta <- Sim_call(n, M, S_0, K, r, sigma, T, theta)
CEV_results$Asian_Eul[i] <- Asian_theta$Eul$payoff
CEV_results$Asian_Mil[i] <- Asian_theta$Mil$payoff
qqplot(q, sort(Asian_theta$Eul$price),
ylab="Sample quantiles", main="Euler scheme")
abline(lsfit(q, sort(Asian_theta$Eul$price)))
qqplot(q, sort(Asian_theta$Mil$price),
ylab="Sample quantiles", main="Milstein scheme")
abline(lsfit(q, sort(Asian_theta$Mil$price)))
}
CEV_results
hist(Eul_diff, xlim=c(-1, 1))
hist(Eul_diff)
theta <- 1
CEV_results <- data.frame(M=M_lst, n=n, theta=theta,
Asian_Eul=0, Asian_Mil=0, Asian_Ext=0)
set.seed(4002)
bootstrapped <- Sim_Milstein(1e6, 1e4, S_0, K, r, sigma, T, theta)
i <- ((1:n) - 0.5)/n
q <- quantile(bootstrapped, probs=i, type=4, names=FALSE)
for (i in 1:length(M_lst)){
M <- M_lst[i]
Asian_theta <- Sim_call(n, M, S_0, K, r, sigma, T, theta)
CEV_results$Asian_Eul[i] <- Asian_theta$Eul$payoff
CEV_results$Asian_Mil[i] <- Asian_theta$Mil$payoff
qqplot(q, sort(Asian_theta$Eul$price),
ylab="Sample quantiles", main="Euler scheme")
abline(lsfit(q, sort(Asian_theta$Eul$price)))
qqplot(q, sort(Asian_theta$Mil$price),
ylab="Sample quantiles", main="Milstein scheme")
abline(lsfit(q, sort(Asian_theta$Mil$price)))
Eul_diff <- q - sort(Asian_theta$Eul$price)
Ext_diff <- q - sort(Asian_theta$Mil$price)
hist(Eul_diff, xlab="Error", main="Euler Scheme")
hist(Ext_diff, xlab="Error", main="Milstein Scheme")
}
CEV_results
hist(Eul_diff, xlab="Error", main="Euler Scheme", x_lim=c(-0.05, 0.05))
hist(Ext_diff, xlab="Error", main="Milstein Scheme", x_lim=c(-0.05, 0.05))
hist(Eul_diff, xlab="Error", main="Euler Scheme", xlim=c(-0.05, 0.05))
hist(Ext_diff, xlab="Error", main="Milstein Scheme", xlim=c(-0.05, 0.05))
?hist
hist(Eul_diff, xlab="Error", main="Euler Scheme", breaks=200)
hist(Ext_diff, xlab="Error", main="Milstein Scheme", breaks=200)
hist(Eul_diff, xlab="Error", main="Euler Scheme",
breaks=200, xlim=c(-0.05, 0.05))
hist(Ext_diff, xlab="Error", main="Milstein Scheme",
breaks=200, xlim=c(-0.05, 0.05))
M
hist(Eul_diff, xlab="Error", main="Euler Scheme",
breaks=300, xlim=c(-0.05, 0.05))
hist(Mil_diff, xlab="Error", main="Milstein Scheme",
breaks=300, xlim=c(-0.05, 0.05))
hist(Eul_diff, xlab="Error", main="Euler Scheme",
breaks=300, xlim=c(-0.05, 0.05))
hist(Mil_diff, xlab="Error", main="Milstein Scheme",
breaks=300, xlim=c(-0.05, 0.05))
Mil_diff <- q - sort(Asian_theta$Mil$price)
hist(Eul_diff, xlab="Error", main="Euler Scheme",
breaks=300, xlim=c(-0.05, 0.05))
hist(Mil_diff, xlab="Error", main="Milstein Scheme",
breaks=300, xlim=c(-0.05, 0.05))
hist(Eul_diff, xlab="Error", main="Euler Scheme",
breaks=1000, xlim=c(-0.03, 0.03))
hist(Mil_diff, xlab="Error", main="Milstein Scheme",
breaks=1000, xlim=c(-0.03, 0.03))
library("tseries")
?arima.sim
set.seed(4002)
AR_2 <- arima.sim(n=200, list(ar=c(0.8897, -0.4858)), sd=sqrt(0.1796))
MA_2 <- arima.sim(n=200, list(ma=c(-0.2279, 0.2488)), sd=sqrt(0.1796))
par(mfrow=c(1,2))
acf(AR_2); pacf(AR_2)
acf(MA_2); pacf(MA_2)
set.seed(4002)
AR_2 <- arima.sim(n=200, list(ar=c(0.8897, -0.4858)), sd=sqrt(0.1796))
MA_2 <- arima.sim(n=200, list(ma=c(0.8897, -0.4858)), sd=sqrt(0.1796))
par(mfrow=c(1,2))
acf(AR_2); pacf(AR_2)
acf(MA_2); pacf(MA_2)
set.seed(4002)
AR_2 <- arima.sim(n=200, list(ar=c(0.8897, 0.4858)), sd=sqrt(0.1796))
set.seed(4002)
AR_2 <- arima.sim(n=200, list(ar=c(0.4897, 0.4858)), sd=sqrt(0.1796))
MA_2 <- arima.sim(n=200, list(ma=c(0.4897, 0.4858)), sd=sqrt(0.1796))
par(mfrow=c(1,2))
acf(AR_2); pacf(AR_2)
acf(MA_2); pacf(MA_2)
MA_2 <- arima.sim(n=200, list(ma=c(0.1897, 0.4858)), sd=sqrt(0.1796))
par(mfrow=c(1,2))
acf(AR_2); pacf(AR_2)
acf(MA_2); pacf(MA_2)
set.seed(4002)
AR_2 <- arima.sim(n=200, list(ar=c(0.4897, 0.4858)), sd=sqrt(0.1796))
set.seed(4002)
MA_2 <- arima.sim(n=200, list(ma=c(0.1897, 0.4858)), sd=sqrt(0.1796))
par(mfrow=c(1,2))
acf(AR_2); pacf(AR_2)
acf(MA_2); pacf(MA_2)
set.seed(4002)
AR_2 <- arima.sim(n=200, list(ar=c(0.2897, 0.4858)), sd=1)
set.seed(4002)
MA_2 <- arima.sim(n=200, list(ma=c(0.1897, 0.4858)), sd=1)
par(mfrow=c(1,2))
acf(AR_2); pacf(AR_2)
acf(MA_2); pacf(MA_2)
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(keras)        # MNIST dataset
# Load MNIST dataset
mnist <- dataset_mnist()
X_train <- mnist$train$x
y_train <- mnist$train$y
X <- rbind(X_train, X_test)
X_test <- mnist$test$x
y_test <- mnist$test$y
X <- rbind(X_train, X_test)
dim(X)
X <- cbind(X_train, X_test)
dim(X)
dim(X_train)
X <- c(X_train, X_test)
dim(X)
X
par(mfrow=c(10,10))
X_train_2 <- X_train[y_train == 2]
X_test_2 <- X_test[y_test == 2]
for (i in 1:length(X_train_2)){
image(X_train_2[i])
}
X_train_2[i]
i
X_train_2 <- X_train[y_train == 2]
X_test_2 <- X_test[y_test == 2]
dim(X_train_2)
X_train[y_train == 2]
dim(X_train)
y_train == 2
dim(X_train[y_train == 2])
X_train_2 <- X_train[which(y_train==2),,]
X_test_2 <- X_test[which(y_test==2),,]
for (i in 1:length(X_train_2)){
image(X_train_2[i])
}
dim(X_train_2)
X_train_2[i]
1:length(X_train_2)
length(X_train_2)
nrow(X_train_2)
i = 1
X_train_2[i]
for (i in 1:nrow(X_train_2)){
image(X_train_2[i,,])
}
par(mfrow=c(10,10))
for (i in 1:nrow(X_train_2)){
image(X_train_2[i,,])
}
# Limit the pixel value between 0 and 1 to avoid computational explode
X_train[X_train!=0] <- 1
X_test[X_test!=0] <- 1
X_train_2 <- X_train[which(y_train==2),,]
X_test_2 <- X_test[which(y_test==2),,]
par(mfrow=c(10,10))
for (i in 1:nrow(X_train_2)){
image(X_train_2[i,,])
}
par(mfrow=c(1,10))
for (i in 1:nrow(X_train_2)){
image(X_train_2[i,,])
}
image(t(apply(X_train_2[m,,], 2, rev)))
image(t(apply(X_train_2[i,,], 2, rev)))
par(mfrow=c(3,3))
image(t(apply(X_train_2[i,,], 2, rev)))
image(X_train_2[i,,])
?image
image(t(apply(X_train_2[i,,], 2, rev)), col="gray")
x <- heatmap(X_train_2[i,,],Rowv=NA,Colv=NA,col=grays, scale = "none")
grays = rgb(red = 0:255/255, blue = 0:255/255, green = 0:255/255)
x <- heatmap(X_train_2[i,,],Rowv=NA,Colv=NA,col=grays, scale = "none")
image(t(apply(x, 2, rev)))
image(x)
x
plot(x)
X_train <- mnist$train$x
y_train <- mnist$train$y
X_test <- mnist$test$x
y_test <- mnist$test$y
# Limit the pixel value between 0 and 1 to avoid computational explode
X_train[X_train!=0] <- 1
X_test[X_test!=0] <- 1
X_train_2 <- X_train[which(y_train==2),,]
X_test_2 <- X_test[which(y_test==2),,]
grays = rgb(red = 0:255/255, blue = 0:255/255, green = 0:255/255)
par(mfrow=c(3,3))
for (i in 1:nrow(X_train_2)){
image(t(apply(X_train_2[i,,], 2, rev)))
}
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
par(mfrow=c(3,3))
for (i in 1:nrow(X_train_2)){
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
cat(i)
}
par(mfrow=c(4,4))
for (i in 1:nrow(X_train_2)){
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
cat(paste(i, nrow(X_train_2)))
cat('\014')
}
par(mfrow=c(4,4))
for (i in 1:nrow(X_train_2)){
cat(paste(i, nrow(X_train_2)))
image(t(apply(X_train_2[i,,], 2, rev)), main=i)
cat('\014')
}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
d <- read.csv("../Datasets/stock_1999_2002.csv", row.names=1) # read in data file
d <- as.ts(d)
returns <- (lag(d) - d)/d
colnames(returns) <- paste0(colnames(d), "_Return")
n_sim <- 1e5
# compute pseudo observations
library(copula)  # Package for copula computation
emp_u <- pobs(returns, ties.method="average")
par(mfrow=c(1,3))
# Q-Q plot for pseudo observations
col <- c("blue", "orange", "green")
n_days <- nrow(returns)
q <- ((1:n_days) - 0.5) / n_days
for (k in 1:ncol(returns)){
qqplot(q, sort(emp_u[,k]), col=col[k],
xlab="Theoretical quantiles", ylab="Sample quantiles",
main=paste0("Q-Q Plot of ", colnames(returns)[k]))
abline(lsfit(q, sort(emp_u[,k])), lwd=2)
}
par(mfrow=c(1, 1))
pseudo_quantile <- function(p, samples){
q <- matrix(NA, nrow=nrow(p), ncol=ncol(p))
for (k in 1:ncol(p)){
q[,k] <- quantile(samples[,k], probs=p[,k], type=4, names=FALSE)
}
return (q)
}
################################################################################
# Assume a normal-copula with ncol(d)=3
# P2p: array of elements of upper triangular matrix
N.cop <- normalCopula(dim=ncol(d), dispstr="un")
fit <- fitCopula(N.cop, emp_u, "ml")
(rho <- coef(fit))
N.cop_fit <- normalCopula(rho, dim=ncol(d), dispstr="un")
set.seed(4002)
# Generate random samples u~U(0, 1) from the fitted gaussian copula
u_sim_N <- rCopula(n_sim, N.cop_fit)
colnames(u_sim_N) <- colnames(d)
pairs(u_sim_N[1:1e3,], col="blue")        # only show the first 1000
cor(u_sim_N)
cor(returns)
# Get back returns based on the random samples
return_sim_N <- pseudo_quantile(u_sim_N, returns)
colnames(return_sim_N) <- colnames(d)
pairs(return_sim_N[1:1e3,], col="green")  # only show the first 1000
################################################################################
Mahalanobis2 <- function(X){
mu <- apply(X, 2, mean)
inv_Sig <- solve(cov(X))
X_minus_mu <- sweep(X, 2, mu, FUN="-")
return (rowSums((X_minus_mu %*% inv_Sig) * X_minus_mu))
}
QQ_Plot <- function(sim_data, raw_data, col="blue"){
n_days <- length(raw_data)
i <- ((1:n_days) - 0.5) / n_days
q <- quantile(sim_data, probs=i, type=4, names=FALSE)
qqplot(q, sort(raw_data), col=col,
xlab="Bootstrapped quantiles", ylab="Sample quantiles",
main="Copula Q-Q Plot")
abline(0, 1, lwd=2)
}
returns_md2 <- Mahalanobis2(returns)
################################################################################
sim_N_md2 <- Mahalanobis2(return_sim_N)
QQ_Plot(sim_N_md2, returns_md2, col="blue")
i <- ((1:n_days) - 0.5) / n_days
q <- qchisq(i, 3)
qqplot(q, sort(returns_md2), main="Chi2 Q-Q Plot")
abline(lsfit(q, sort(returns_md2)))
################################################################################
# Assume a t-copula  with ncol(d)=3
t.cop <- tCopula(dim=ncol(d), dispstr='un')
fit <- fitCopula(t.cop, emp_u, "ml")
(rho <- coef(fit)[1:ncol(d)])
(df <- coef(fit)[length(coef(fit))])
t.cop_fit <- tCopula(dim=ncol(d), rho, df=df, dispstr="un")
# Generate random samples u~U(0, 1) from the fitted t copula
u_sim_t <- rCopula(n_sim, t.cop_fit)
colnames(u_sim_t) <- colnames(d)
pairs(u_sim_t[1:1e3,], col="blue")        # only show the first 1000
# Get back returns based on the random samples
return_sim_t <- pseudo_quantile(u_sim_t, returns)
colnames(return_sim_t) <- colnames(d)
pairs(return_sim_t[1:1e3,], col="green")  # only show the first 1000
################################################################################
sim_t_md2 <- Mahalanobis2(return_sim_t)
QQ_Plot(sim_t_md2, returns_md2, col="orange")
################################################################################
n_days <- nrow(returns)
i <- ((1:n_days) - 0.5) / n_days
q_N <- quantile(sim_N_md2, probs=i, type=4, names=FALSE)
q_t <- quantile(sim_t_md2, probs=i, type=4, names=FALSE)
a <- 15
leg <- c("Gaussian copula", "t-copula")
# find the common index where both coordinates > a
sort_returns_md2 <- sort(returns_md2)
idx <- min(Reduce(intersect, list(which(q_N > a), which(q_t > a),
which(sort_returns_md2 > a))))
(idx_start <- min(idx))
plot(q_N[idx_start:n_days], sort_returns_md2[idx_start:n_days],
xlab="Bootstrapped quantiles", ylab="Sample quantiles",
main="Copula Q-Q Plot",
pch=1, cex=1.5, col="blue", xlim=c(a, max(q_N, q_t)))
points(q_t[idx_start:n_days], sort_returns_md2[idx_start:n_days],
pch=4, cex=1.5, lwd=2, col="orange")
legend("topleft", pch=c(1, 4), cex=1.5, lwd=c(1, 2),
col=c("blue", "orange"), lty=0, legend=leg)
abline(0, 1, lwd=2)
################################################################################
# residuals with respect to the 45-degree line
sort_resid2_N <- sort((sort(returns_md2) - q_N)^2)
sort_resid2_t <- sort((sort(returns_md2) - q_t)^2)
# plot the largest 50 and skip the largest (last) entry
idx_plots <- (n_days-50):(n_days-1)
plot(sort_resid2_N[idx_plots], ylab="squared residuals",
ylim=c(0, max(sort_resid2_N[idx_plots], sort_resid2_t[idx_plots])),
pch=1, cex=1.5, col="blue")
points(sort_resid2_t[idx_plots], pch=4, cex=1.5, lwd=2, col="orange")
legend("topleft", pch=c(1, 4), cex=1.5, lwd=c(1, 2),
col=c("blue", "orange"), lty=0, legend=leg)
sort_resid2_N <- sort((sort(returns_md2) - q_N)^2)
sort_resid2_t <- sort((sort(returns_md2) - q_t)^2)
# plot the largest 50
idx_plots <- (n_days-50):(n_days)
plot(sort_resid2_N[idx_plots], ylab="squared residuals",
ylim=c(0, max(sort_resid2_N[idx_plots], sort_resid2_t[idx_plots])),
pch=1, cex=1.5, col="blue")
points(sort_resid2_t[idx_plots], pch=4, cex=1.5, lwd=2, col="orange")
legend("topleft", pch=c(1, 4), cex=1.5, lwd=c(1, 2),
col=c("blue", "orange"), lty=0, legend=leg)
sort_resid2_N <- sort((sort(returns_md2) - q_N)^2)
sort_resid2_t <- sort((sort(returns_md2) - q_t)^2)
# plot the largest 50
idx_plots <- (n_days-50):(n_days)
plot(sort_resid2_N[idx_plots], ylab="squared residuals",
ylim=c(0, max(sort_resid2_N[idx_plots], sort_resid2_t[idx_plots])),
pch=1, cex=1.5, col="blue")
points(sort_resid2_t[idx_plots], pch=4, cex=1.5, lwd=2, col="orange")
legend("topleft", pch=c(1, 4), cex=1.5, lwd=c(1, 2),
col=c("blue", "orange"), lty=0, legend=leg)
sort_resid2_N <- sort((sort(returns_md2) - q_N)^2)
sort_resid2_t <- sort((sort(returns_md2) - q_t)^2)
# plot the largest 50
idx_plots <- (n_days-50):(n_days)
plot(sort_resid2_N[idx_plots], ylab="squared residuals",
ylim=c(0, max(sort_resid2_N[idx_plots], sort_resid2_t[idx_plots])),
pch=1, cex=1.5, col="blue")
points(sort_resid2_t[idx_plots], pch=4, cex=1.5, lwd=2, col="orange")
legend("topleft", pch=c(1, 4), cex=1.5, lwd=c(1, 2),
col=c("blue", "orange"), lty=0, legend=leg)
# residuals with respect to the 45-degree line
sort_resid2_N <- sort((sort(returns_md2) - q_N)^2)
sort_resid2_t <- sort((sort(returns_md2) - q_t)^2)
# plot the largest 50 and skip the largest (last) entry
idx_plots <- (n_days-50):(n_days-1)
plot(sort_resid2_N[idx_plots], ylab="squared residuals",
ylim=c(0, max(sort_resid2_N[idx_plots], sort_resid2_t[idx_plots])),
pch=1, cex=1.5, col="blue")
points(sort_resid2_t[idx_plots], pch=4, cex=1.5, lwd=2, col="orange")
legend("topleft", pch=c(1, 4), cex=1.5, lwd=c(1, 2),
col=c("blue", "orange"), lty=0, legend=leg)
