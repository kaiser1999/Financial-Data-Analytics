n_stocks <- ncol(returns); n_days <- nrow(returns)
if (is.na(col)) col <- rep("black", n_stocks)
par(mfrow=c(1, n_stocks))
set.seed(seed)
for (k in 1:n_stocks){
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
inverted_k_quantile <- ecdf(sim_data_k)(sim_data_k)
i <- ((1:n_days) - 0.5) / n_days
q <- predict(i, interp(inverted_k_quantile))
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
}
}
total_sim <- 1e4; col <- c("blue", "orange", "green")
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
Empirical_QQ_Plot <- function(sim_data, returns, seed=4002, col=c()){
n_stocks <- ncol(returns); n_days <- nrow(returns)
if (len(col) = 0) col <- rep("black", n_stocks)
Empirical_QQ_Plot <- function(sim_data, returns, seed=4002, col=c()){
n_stocks <- ncol(returns); n_days <- nrow(returns)
if (len(col) == 0) col <- rep("black", n_stocks)
par(mfrow=c(1, n_stocks))
set.seed(seed)
for (k in 1:n_stocks){
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
inverted_k_quantile <- ecdf(sim_data_k)(sim_data_k)
i <- ((1:n_days) - 0.5) / n_days
q <- predict(i, interp(inverted_k_quantile))
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
}
}
total_sim <- 1e4; col <- c("blue", "orange", "green")
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
empirical_quantile <- function(x) ecdf(x)(x)
Empirical_QQ_Plot <- function(sim_data, returns, seed=4002, col=c()){
n_stocks <- ncol(returns); n_days <- nrow(returns)
if (length(col) == 0) col <- rep("black", n_stocks)
par(mfrow=c(1, n_stocks))
set.seed(seed)
for (k in 1:n_stocks){
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
inverted_k_quantile <- ecdf(sim_data_k)(sim_data_k)
i <- ((1:n_days) - 0.5) / n_days
q <- predict(i, interp(inverted_k_quantile))
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
}
}
total_sim <- 1e4; col <- c("blue", "orange", "green")
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
?interp
sim_data <- sim_N
returns <- return
n_stocks <- ncol(returns); n_days <- nrow(returns)
k = 1
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
inverted_k_quantile <- ecdf(sim_data_k)(sim_data_k)
i <- ((1:n_days) - 0.5) / n_days
q <- interp(inverted_k_quantile, z=i, output="points")
q
q()
q
interp(inverted_k_quantile, z=i, output="points")
interp(i, z=inverted_k_quantile, output="points")
interp(i, i, z=inverted_k_quantile, output="points")
approx(1:n_days, inverted_k_quantile, xout=i)$y
length(inverted_k_quantile)
approx(1:length(inverted_k_quantile), inverted_k_quantile, xout=i)$y
dat <- 1:10
my_ecdf <- ecdf(dat)
my_ecdf
?quantile
quantile(ecdf(sim_data_k), probs=i)
quantile(inverted_k_quantile, probs=i)
q <- quantile(inverted_k_quantile, probs=i)
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
q <- quantile(ecdf(sim_data_k), probs=i)
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
Empirical_QQ_Plot <- function(sim_data, returns, col=c()){
n_stocks <- ncol(returns); n_days <- nrow(returns)
if (length(col) == 0) col <- rep("black", n_stocks)
par(mfrow=c(1, n_stocks))
for (k in 1:n_stocks){
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
inverted_k_quantile <- ecdf(sim_data_k)(sim_data_k)
i <- ((1:n_days) - 0.5) / n_days
q <- quantile(inverted_k_quantile, probs=i)
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
}
}
total_sim <- 1e4; col <- c("blue", "orange", "green")
set.seed(4002)
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
set.seed(4002)
sim_t <- rMvdc(total_sim, t_cop_dist)
# Assume a t-copula  with ncol(d)=3
t.cop <- tCopula(dim=ncol(d), dispstr='un')
m <- pobs(return)
fit <- fitCopula(t.cop, m, "ml")
(rho <- coef(fit)[1:ncol(d)])
(df <- coef(fit)[length(coef(fit))])
# Generate random samples u~U(0, 1) based on the fitted t copula
u_sim <- rCopula(n_sim, tCopula(dim=ncol(d), rho, df=df, dispstr="un"))
pairs(u_sim, col="blue")
cor(u_sim)
cor(d)
t.nu <- function(u){
z <- u - mean(u)              # Remove mean
n <- length(z)                # sample size
s <- sd(z)*sqrt((n-1)/n)      # Population standard deviation
ku <- sum(z^4)/(n*s^4) - 3    # Excess kurtosis
6/ku + 4                      # Degrees of freedom
}
t_cop_dist <- mvdc(copula=tCopula(rho, dim=ncol(d), df=df, dispstr="un"),
margins=rep("norm", ncol(d)),
paramMargins=list(list(mean=mean(u1), sd=sd(u1)),
list(mean=mean(u2), sd=sd(u2)),
list(mean=mean(u3), sd=sd(u3))))
# Generate random return samples based on multi-variate t copula
set.seed(4002)
return_sim_t <- rMvdc(n_sim, t_cop_dist)
pairs(rbind(return, return_sim_t), col=c("orange","blue"))
######################################################################
set.seed(4002)
sim_t <- rMvdc(total_sim, t_cop_dist)
Empirical_QQ_Plot(sim_t, return, col=col)
q <- quantile(ecdf(sim_data_k), probs=i)
set.seed(4002)
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
Empirical_QQ_Plot(sim_N, return, col=col)
q <- quantile(ecdf(sim_data_k), probs=i)
q
as.numeric(a)
as.numeric(q)
Empirical_QQ_Plot <- function(sim_data, returns, col=c()){
n_stocks <- ncol(returns); n_days <- nrow(returns)
if (length(col) == 0) col <- rep("black", n_stocks)
par(mfrow=c(1, n_stocks))
for (k in 1:n_stocks){
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
inverted_k_quantile <- ecdf(sim_data_k)(sim_data_k)
i <- ((1:n_days) - 0.5) / n_days
q <- quantile(ecdf(sim_data_k), probs=i)
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
}
}
######################################################################
total_sim <- 1e4; col <- c("blue", "orange", "green")
set.seed(4002)
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
set.seed(4002)
sim_t <- rMvdc(total_sim, t_cop_dist)
Empirical_QQ_Plot(sim_t, return, col=col)
Empirical_QQ_Plot <- function(sim_data, returns, col=c()){
n_stocks <- ncol(returns); n_days <- nrow(returns)
if (length(col) == 0) col <- rep("black", n_stocks)
par(mfrow=c(1, n_stocks))
for (k in 1:n_stocks){
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
inverted_k_quantile <- ecdf(sim_data_k)(sim_data_k)
i <- ((1:n_days) - 0.5) / n_days
q <- quantile(ecdf(sim_data_k), probs=i)
q <- quantile(sim_data_k, probs=i)
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
}
}
total_sim <- 1e4; col <- c("blue", "orange", "green")
######################################################################
set.seed(4002)
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
d <- read.csv("stock_1999_2002.csv", row.names=1) # read in data file
d <- as.ts(d)
return <- (lag(d) - d)/d
colnames(return) <- paste0(colnames(d), "_Return")
u1 <- return[,"HSBC_Return"]
u2 <- return[,"CLP_Return"]
u3 <- return[,"CK_Return"]
n_sim <- 1000
library(copula)  # Package for copula computation
# Assume a normal-copula with ncol(d)=3
# P2p: array of elements of upper triangular matrix
N.cop <- normalCopula(P2p(cor(d)), dim=ncol(d), dispstr="un")
set.seed(4002)
# Generate random samples u~U(0, 1) based on gaussian copula
u_sim <- rCopula(n_sim, N.cop)
pairs(u_sim, col="blue")
cor(u_sim)
cor(d)
# mvdc:  Multi-Variate Distribution Copula
N_cop_dist <- mvdc(copula=N.cop, margins=rep("norm", ncol(d)),
paramMargins=list(list(mean=mean(u1), sd=sd(u1)),
list(mean=mean(u2), sd=sd(u2)),
list(mean=mean(u3), sd=sd(u3))))
# Generate random return samples based on multi-variate normal copula
set.seed(4002)
return_sim_N <- rMvdc(n_sim, N_cop_dist)
pairs(rbind(return, return_sim_N), col=c("orange","blue"))
######################################################################
Empirical_QQ_Plot <- function(sim_data, returns, col=c()){
n_stocks <- ncol(returns); n_days <- nrow(returns)
if (length(col) == 0) col <- rep("black", n_stocks)
par(mfrow=c(1, n_stocks))
for (k in 1:n_stocks){
sim_data_k <- sim_data[,k]; returns_k <- returns[,k]
i <- ((1:n_days) - 0.5) / n_days
q <- quantile(ecdf(sim_data_k), probs=i)
qqplot(q, sort(returns_k), xlab="Empirical quantiles",
ylab="Returns quantiles", col=col[k],
main=paste(colnames(returns)[k], "Empirical Q-Q Plot"))
abline(lsfit(q, sort(returns_k)))
}
}
total_sim <- 1e5; col <- c("blue", "orange", "green")
######################################################################
set.seed(4002)
sim_N <- rMvdc(total_sim, N_cop_dist)
Empirical_QQ_Plot(sim_N, return, col=col)
######################################################################
# Assume a t-copula  with ncol(d)=3
t.cop <- tCopula(dim=ncol(d), dispstr='un')
m <- pobs(return)
fit <- fitCopula(t.cop, m, "ml")
(rho <- coef(fit)[1:ncol(d)])
(df <- coef(fit)[length(coef(fit))])
# Generate random samples u~U(0, 1) based on the fitted t copula
u_sim <- rCopula(n_sim, tCopula(dim=ncol(d), rho, df=df, dispstr="un"))
pairs(u_sim, col="blue")
cor(u_sim)
cor(d)
t.nu <- function(u){
z <- u - mean(u)              # Remove mean
n <- length(z)                # sample size
s <- sd(z)*sqrt((n-1)/n)      # Population standard deviation
ku <- sum(z^4)/(n*s^4) - 3    # Excess kurtosis
6/ku + 4                      # Degrees of freedom
}
t_cop_dist <- mvdc(copula=tCopula(rho, dim=ncol(d), df=df, dispstr="un"),
margins=rep("norm", ncol(d)),
paramMargins=list(list(mean=mean(u1), sd=sd(u1)),
list(mean=mean(u2), sd=sd(u2)),
list(mean=mean(u3), sd=sd(u3))))
# Generate random return samples based on multi-variate t copula
set.seed(4002)
return_sim_t <- rMvdc(n_sim, t_cop_dist)
pairs(rbind(return, return_sim_t), col=c("orange","blue"))
######################################################################
set.seed(4002)
sim_t <- rMvdc(total_sim, t_cop_dist)
Empirical_QQ_Plot(sim_t, return, col=col)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
df <- read.csv('Mroz.csv') # read the dataset
# create a new column of number of children under 18
df$child <- df$child6 + df$child618
# remove the '#','child6', 'child618' columns
df <- df[,-c(1,4,5)]
# fit the 1st model with all features
model_1 <- glm(formula=child~., family=poisson, data=df)
summary(model_1)  # print summary of the 1st model
################################################################################
# fit the 2nd model with the remaining features
model_2 <- glm(formula=child~work+hoursw+agew+income+experience,
family=poisson, data=df)
summary(model_2)          # print summary of the 2nd model
# fit the 3rd model with the remaining features
model_3 <- glm(formula=child~hoursw+agew+experience,
family=poisson, data=df)
summary(model_3)          # print summary of the 3rd model
df <- read.csv('Mroz.csv')  # read the dataset
# create a new feature: number of children under 18
df$child <- df$child6 + df$child618
# remove the '#','child6', 'child618' features
df <- df[,-c(1,4,5)]
# fit the 1st model with all features
model_1 <- glm(formula=child~., family=poisson, data=df)
summary(model_1)            # print summary of the 1st model
# fit the 2nd model with the remaining features
model_2 <- glm(formula=child~work+hoursw+agew+income+experience,
family=poisson, data=df)
summary(model_2)            # print summary of the 2nd model
# fit the 3rd model with the remaining features
model_3 <- glm(formula=child~hoursw+agew+experience,
family=poisson, data=df)
summary(model_3)            # print summary of the 3rd model
# Initialize variables
S_0 <- 10; q <- 0; sigma <- 0.7; r <- 0; T <- 1; K <- 8; h <- 0.3
params <- list(mean=(r-q-sigma^2/2)*T, sd=sigma*sqrt(T))
params_plus_h <- list(mean=(r-q-(sigma+h)^2/2)*T, sd=(sigma+h)*sqrt(T))
params_minus_h <- list(mean=(r-q-(sigma-h)^2/2)*T,sd=(sigma-h)*sqrt(T))
discount <- exp(-r * T)
# Compute the exact Delta and Vega
d_plus <- (log(S_0/K) + (r-q+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
################################################################################
set.seed(4002)
# Create a data frame to store results
results <- data.frame(n=numeric(0), exact_delta=numeric(0),
exact_vega=numeric(0),
est_delta_forward=numeric(0),
est_vega_forward=numeric(0),
est_delta_central=numeric(0),
est_vega_central=numeric(0))
n_size <- c(1e6, 1e8)
# Estimate Delta and Vega using forward and central difference
# with different n
for (n in n_size) {
# Generate the Black-Scholes sample
S_T <- S_0 * exp(do.call(rnorm, c(n, params)))
# Estimate Delta using forward and central difference method
Y_bar_S0 <- discount * mean(pmax(S_T - K, 0))
S_T_minus_h <- (S_0 - h)  * exp(do.call(rnorm, c(n, params)))
Y_bar_S0_minus_h <- discount * mean(pmax(S_T_minus_h - K, 0))
S_T_plus_h <- (S_0 + h) * exp(do.call(rnorm, c(n, params)))
Y_bar_S0_plus_h <- discount * mean(pmax(S_T_plus_h - K, 0))
est_delta_forward <- (Y_bar_S0_plus_h - Y_bar_S0) / h
est_delta_central<- (Y_bar_S0_plus_h - Y_bar_S0_minus_h) / (2*h)
# Estimate Vega using forward and central difference method
Y_bar_sigma <- Y_bar_S0
S_T_minus_h <- S_0  * exp(do.call(rnorm, c(n, params_minus_h)))
Y_bar_sigma_minus_h <- discount * mean(pmax(S_T_minus_h - K, 0))
S_T_plus_h <- S_0  * exp(do.call(rnorm, c(n, params_plus_h)))
Y_bar_sigma_plus_h <- discount * mean(pmax(S_T_plus_h - K, 0))
est_vega_forward <- (Y_bar_sigma_plus_h - Y_bar_sigma)/h
est_vega_central<- (Y_bar_sigma_plus_h - Y_bar_sigma_minus_h)/(2*h)
# Store the results in the data frame
output <- data.frame(h=h, n=n, exact_delta=exact_delta,
est_delta_forward=est_delta_forward,
est_delta_central=est_delta_central,
exact_vega=exact_vega,
est_vega_forward=est_vega_forward,
est_vega_central=est_vega_central)
results <- rbind(results, output)
}
################################################################################
# Subset results for Delta
(delta_results <- results[, c(1,2,3,4,5)])
# Relative error
abs(results$est_delta_forward - exact_delta) / exact_delta * 100
abs(results$est_delta_central - exact_delta) / exact_delta * 100
# Subset results for Vega
(vega_results <- results[, c(1,2,6,7,8)])
# Relative error
abs(results$est_vega_forward - exact_vega) / exact_vega * 100
abs(results$est_vega_central - exact_vega) / exact_vega * 100
################################################################################
set.seed(4002)
n_size <- seq(400, 30000, by=400)
est_delta_pathwise <- c()
est_vega_pathwise <- c()
# Estimate Delta and Vega using pathwise method with different n
for (i in 1:length(n_size)) {
# Generate the Black-Scholes sample
S_T <- S_0 * exp(do.call(rnorm, c(n_size[i], params)))
# Estimate delta using pathwise method
result <- (S_T > K) * S_T / S_0
est_delta_pathwise[i] <- discount * mean(result)
# Estimate vega using pathwise method
result <- (S_T > K) * S_T *(log( S_T / S_0)-(r-q+sigma^2/2)*T)
est_vega_pathwise[i] <- discount / sigma * mean(result)
}
# Plot the graph of estimated Delta and exact Delta
plot(n_size, est_delta_pathwise, type="o", col="red", ylim=c(0.5, 1),
xlab="number of paths", ylab="Delta", main="", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", legend=c("pathwise estimate", "exact"),
col=c("red", "blue"), lwd=1.5, pch=c(21, NA))
# Plot the graph of estimated Vega and exact Vega
plot(n_size, est_vega_pathwise, type="o", col="red", ylim=c(2,4.5),
xlab="number of paths", ylab="Vega", main="", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", legend=c("pathwise estimate", "exact"),
col=c("red", "blue"), lwd=1.5, pch=c(21, NA))
################################################################################
set.seed(4002)
n_size <- seq(400, 30000, by=400)
est_delta_lr <- c()
est_vega_lr <- c()
# Estimate Delta using pathwise method with different n
for (i in 1:length(n_size)) {
# Generate the Black-Scholes sample
S_T <- S_0 * exp(do.call(rnorm, c(n_size[i], params)))
# Estimate Delta using pathwise method
result <- (S_T > K) * S_T / S_0
est_delta_pathwise[i] <- discount * mean(result)
# Estimate Vega using pathwise method
result <- (S_T > K)*S_T*(log(S_T/S_0) - (r - q + sigma^2/2)*T)
est_vega_pathwise[i] <- discount / sigma * mean(result)
# Estimate Delta using likelihood ratio method
h <- (log(S_T/S_0) - ((r - sigma^2/2)*T)) / (sigma*sqrt(T))
result <- pmax(S_T - K, 0) * h / (S_0 * sigma * sqrt(T))
est_delta_lr[i] <- mean(discount * result)
# Estimate Vega using likelihood ratio method
result <- pmax(S_T - K, 0) * (-1/sigma + h^2/sigma -sqrt(T)*h)
est_vega_lr[i] <- mean(discount * result)
}
# Plot the graph of estimated Delta and exact Delta
plot(n_size, est_delta_pathwise, type="o", col="red", ylim=c(0.5, 1),
xlab="number of paths", ylab="Delta", main="", lwd=1.5, pch=21)
lines(n_size, est_delta_lr, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise estimate", "likelihood ratio estimate",
"exact"), pch=c(21, 21, NA))
# Plot the graph of estimated Vega and exact Vega
plot(n_size, est_vega_pathwise, type="o", col="red", ylim=c(2, 4.5),
xlab="number of paths", ylab="Vega", main="", lwd=1.5, pch=21)
lines(n_size, est_vega_lr, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise estimate", "likelihood ratio estimate",
"exact"), pch=c(21, 21, NA))
# Initialize variables
S_0 <- 10; q <- 0; sigma <- 0.7; r <- 0; T <- 1; K <- 8; h <- 0.3
params <- list(mean=(r-q-sigma^2/2)*T, sd=sigma*sqrt(T))
params_plus_h <-list(mean=(r-q-(sigma+h)^2/2)*T,sd=(sigma+h)*sqrt(T))
params_minus_h<-list(mean=(r-q-(sigma-h)^2/2)*T,sd=(sigma-h)*sqrt(T))
discount <- exp(-r * T)
# Compute the exact Delta and Vega
d_plus <- (log(S_0/K) + (r-q+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
set.seed(4002)
n_size <- seq(400, 30000, by=400)
est_delta_pathwise <- c(); est_vega_pathwise <- c()
est_delta_lr <- c(); est_vega_lr <- c()
# Estimate Delta using pathwise method with different n
for (i in 1:length(n_size)) {
# Generate the Black-Scholes sample
S_T <- S_0 * exp(do.call(rnorm, c(n_size[i], params)))
# Estimate Delta using pathwise method
result <- (S_T > K) * S_T / S_0
est_delta_pathwise[i] <- discount * mean(result)
# Estimate Vega using pathwise method
result <- (S_T > K)*S_T*(log(S_T/S_0) - (r - q + sigma^2/2)*T)
est_vega_pathwise[i] <- discount / sigma * mean(result)
# Estimate Delta using likelihood ratio method
h <- (log(S_T/S_0) - ((r - sigma^2/2)*T)) / (sigma*sqrt(T))
result <- pmax(S_T - K, 0) * h / (S_0 * sigma * sqrt(T))
est_delta_lr[i] <- mean(discount * result)
# Estimate Vega using likelihood ratio method
result <- pmax(S_T - K, 0) * (-1/sigma + h^2/sigma -sqrt(T)*h)
est_vega_lr[i] <- mean(discount * result)
}
# Plot the graph of estimated Delta and exact Delta
plot(n_size, est_delta_pathwise, type="o", col="red", ylim=c(0.5, 1),
xlab="number of paths", ylab="Delta", main="", lwd=1.5, pch=21)
lines(n_size, est_delta_lr, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_delta, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise estimate", "likelihood ratio estimate",
"exact"), pch=c(21, 21, NA))
# Plot the graph of estimated Vega and exact Vega
plot(n_size, est_vega_pathwise, type="o", col="red", ylim=c(2, 4.5),
xlab="number of paths", ylab="Vega", main="", lwd=1.5, pch=21)
lines(n_size, est_vega_lr, type="o", col="black", lwd=1.5, pch=21)
abline(h=exact_vega, col="blue", lwd=1.8)
legend("topright", col=c("red", "black", "blue"), lwd=1.5,
legend=c("pathwise estimate", "likelihood ratio estimate",
"exact"), pch=c(21, 21, NA))
library(copula)  # Package for copula computation
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
d <- read.csv("stock_1999_2002.csv", row.names=1) # read in data file
d <- as.ts(d)
return <- (lag(d) - d)/d
colnames(return) <- paste0(colnames(d), "_Return")
u1 <- return[,"HSBC_Return"]
u2 <- return[,"CLP_Return"]
u3 <- return[,"CK_Return"]
n_sim <- 1000
P2p(cor(d))
cor(d)
?normalCopula
toeplitz(cor(d))
toeplitz(P2p(cor(d)))
?copula
?tCopula
t.cop <- tCopula(dim=ncol(d), dispstr='un')
m <- pobs(return)
fit <- fitCopula(t.cop, m, "ml")
(rho <- coef(fit)[1:ncol(d)])
(df <- coef(fit)[length(coef(fit))])
