return(res0$cluster)                  # cluster label
}
for (K in 2:25){
print(K)
km(X_train, K)
}
library(keras)        # MNIST dataset
library(nnet)
# Load MNIST dataset
mnist <- dataset_mnist()
X_train <- mnist$train$x
y_train <- mnist$train$y
X_test <- mnist$test$x
y_test <- mnist$test$y
X_train <- matrix(X_train, nrow=length(y_train))
X_test <- matrix(X_test, nrow=length(y_test))
for (K in 2:25){
print(K)
km(X_train, K)
}
set.seed(4002)
# logV starts from 0; y starts from 1
y <- array(0, 1000)
ln_v <- array(0, 1001)
for (i in 2:1001){
ln_v[i] <- 0.5 - 0.332 * ln_v[i-1] + 0.12 * rnorm(1, 0, 1)
y[i-1] <- sqrt(exp(ln_v[i])) * rnorm(1, 0, 1)
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
# a little bug for t = 0 and t = T + 1, but run it first
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
#alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
set.seed(4002)
# logV starts from 0; y starts from 1
y <- array(0, 1000)
ln_v <- array(0, 1001)
for (i in 2:1001){
ln_v[i] <- 0.5 - 0.332 * ln_v[i-1] + 0.12 * rnorm(1, 0, 1)
y[i-1] <- sqrt(exp(ln_v[i])) * rnorm(1, 0, 1)
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
"""
can you help me rewrite your targeted MH algo, please be more specific, since is no clear illustartion why
we have these procedures
"""
set.seed(4002)
# logV starts from 0; y starts from 1
y <- array(0, 1000)
ln_v <- array(0, 1001)
for (i in 2:1001){
ln_v[i] <- 0.5 - 0.332 * ln_v[i-1] + 0.12 * rnorm(1, 0, 1)
y[i-1] <- sqrt(exp(ln_v[i])) * rnorm(1, 0, 1)
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
# a little bug for t = 0 and t = T + 1, but run it first
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
#alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
phi <- sum(logV[-1]-psi*logV[-(T+1)])/(T + lamb)
psi <- sum(logV[-(T+1)]*(logV[-1]-phi)) / (sum(logV[-(T+1)]^2) + lamb)
lamb <- beta_lamb / (T/2 + alpha_lamb - 1)
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
set.seed(4002)
# logV starts from 0; y starts from 1
y <- array(0, 1000)
ln_v <- array(0, 1001)
for (i in 2:1001){
ln_v[i] <- 0.5 - 0.332 * ln_v[i-1] + 0.12 * rnorm(1, 0, 1)
y[i-1] <- sqrt(exp(ln_v[i])) * rnorm(1, 0, 1)
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
# a little bug for t = 0 and t = T + 1, but run it first
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
# mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
# sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
# phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
#
# mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
# sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
# psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
#
# #alpha_lamb <- alpha_lamb + T/2
#
# beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
# lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
phi <- sum(logV[-1]-psi*logV[-(T+1)])/(T + lamb)
psi <- sum(logV[-(T+1)]*(logV[-1]-phi)) / (sum(logV[-(T+1)]^2) + lamb)
lamb <- beta_lamb / (T/2 + alpha_lamb - 1)
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
set.seed(4002)
# logV starts from 0; y starts from 1
y <- array(0, 1000)
ln_v <- array(0, 1001)
for (i in 2:1001){
ln_v[i] <- 0.5 - 0.332 * ln_v[i-1] + 0.12 * rnorm(1, 0, 1)
y[i-1] <- sqrt(exp(ln_v[i])) * rnorm(1, 0, 1)
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
# a little bug for t = 0 and t = T + 1, but run it first
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
# mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
# sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
# phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
#
# mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
# sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
# psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
#
# #alpha_lamb <- alpha_lamb + T/2
#
# beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
# lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
beta_ <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
phi <- sum(logV[-1]-psi*logV[-(T+1)])/(T + lamb)
psi <- sum(logV[-(T+1)]*(logV[-1]-phi)) / (sum(logV[-(T+1)]^2) + lamb)
lamb <- beta_ / (T/2 + alpha_lamb - 1)
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
#}
set.seed(4002)
# logV starts from 0; y starts from 1
y <- array(0, 1000)
ln_v <- array(0, 1001)
for (i in 2:1001){
ln_v[i] <- 0.5 - 0.332 * ln_v[i-1] + 0.12 * rnorm(1, 0, 1)
y[i-1] <- sqrt(exp(ln_v[i])) * rnorm(1, 0, 1)
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, 1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
# a little bug for t = 0 and t = T + 1, but run it first
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
# mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
# sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
# phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
#
# mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
# sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
# psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
#
# #alpha_lamb <- alpha_lamb + T/2
#
# beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
# lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
beta_ <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
phi <- sum(logV[-1]-psi*logV[-(T+1)])/(T + lamb)
psi <- sum(logV[-(T+1)]*(logV[-1]-phi)) / (sum(logV[-(T+1)]^2) + lamb)
lamb <- beta_ / (T/2 + alpha_lamb - 1)
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
df_returns <- matrix(NA, nrow=3, ncol=5)
for (i in 1:ncol(df_returns)){
sigma[,i] <- rep(1, nrow(df_returns))
}
rep(1, nrow(df_returns))
sigma[,i]
df_returns <- matrix(NA, nrow=3, ncol=5)
sigma = array(NA, dim(df_returns))
for (i in 1:ncol(df_returns)){
sigma[,i] <- rep(1, nrow(df_returns))
}
sigma
tryCatch(NA, error=function(e) {})
?tryCatch
e <- simpleError("test error")
tryCatch(stop(e), error=function(e) {})
a = tryCatch(stop(e), error=function(e) {})
length(a)
a
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
################################################################################
library(rpart)                          # load rpart library
library(rpart.plot)                     # plot rpart object
library(randomForest)
set.seed(4002)
df <- read.csv("../Datasets/fin-ratio.csv")         # read in data in csv format
df$HSI <- as.factor(df$HSI) # change label into factor for classification
rf_clf <- randomForest(HSI~., data=df, ntree=10, mtry=2, importance=TRUE)
y_hat <- predict(rf_clf, newdata=df)
table(y_hat, df$HSI)
getTree(rf_clf, 1, labelVar=TRUE)
