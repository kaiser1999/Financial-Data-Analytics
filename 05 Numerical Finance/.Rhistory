if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
?rinvgamma
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
phi <- mu_phi; psi <- mu_psi; lamb <- beta_lamb/(alpha_lamb + 1)
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
library(invgamma)
seed=4002; num_it=1e5
#MCMC_SV <- function(y, num_it=1e5, seed=4002){
MH_V <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
log_target <- function(logV_t){
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
sigma2 <- lamb / (1 + psi^2)
-0.5*logV_t - y_t^2/(2*exp(logV_t)) - (logV_t - mu_t)^2/(2*sigma2)
}
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
target_diff <- exp(log_target(logV_prop) - log_target(logV_t))
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
} else {
#return (MH_V(logV_, y_t, phi, psi, lamb))
return (logV_t)
}
}
}
MH_V_2 <- function(logV_, y_t, phi, psi, lamb){
logV_old <- logV_[1]; logV_t <- logV_[2]; logV_new <- logV_[3]
mu_t <- (phi*(1-psi) + psi*(logV_new + logV_old)) / (1 + psi^2)
logV_prop <- phi + psi*logV_old + sqrt(lamb)*rnorm(1, 0, sd(y)) # Change rnorm(1)
nominator <- exp(-y_t^2/2 * exp(-logV_prop))
denominator <- exp(-y_t^2/2 * exp(-mu_t) * (1 + mu_t - logV_prop))
target_diff <- nominator / denominator
if (!is.na(target_diff)){
if (runif(1) < min(1, target_diff)){
return (logV_prop)
}
}
return (logV_t)
return (MH_V(logV_, y_t, phi, psi, lamb))
}
# prior: phi ~ N(0, 1); psi ~ N(0, 1); sigma ~ IG(2.5, 0.025)
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
T <- length(y)
set.seed(seed)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
#phi <- 0.6 ; psi <- -0.4; lamb <- 0.2
logV_hist <- matrix(0, nrow=num_it, ncol=T+1)
phi_hist <- array(phi, dim=num_it)
psi_hist <- array(psi, dim=num_it)
lamb_hist <- array(lamb, dim=num_it)
for (t in 2:T+1){
logV_hist[1,t] <- phi + psi * logV_hist[1,t-1] + sqrt(lamb) * rnorm(1, 0, 1)
}
for (i in 2:num_it){
# MH sampling for ln V
logV <- c(logV_hist[i-1,], 0)
for (t in 1:T){
# logV starts from 0; y starts from 1
logV[t+1] <- MH_V(logV[c(t, t+1, t+2)], y[t], phi, psi, lamb)
}
logV <- logV[-(T+2)]
mu_phi <- 0; sig2_phi <- 1; mu_psi <- 0; sig2_psi <- 1; alpha_lamb <- 2.5; beta_lamb <- 0.025
# Gibbs sampling for parameters
mu_phi <- (sig2_phi*sum(logV[-1]-psi*logV[-(T+1)]) + lamb*mu_phi)/(T*sig2_phi + lamb)
sig2_phi <- lamb*sig2_phi/(T*sig2_phi + lamb)
phi <- rnorm(1, mean=mu_phi, sd=sqrt(sig2_phi))
mu_psi <- (sig2_psi*sum(logV[-(T+1)]*(logV[-1]-phi)) + lamb*mu_psi) / (sig2_psi*sum(logV[-(T+1)]^2) + lamb)
sig2_psi <- lamb*sig2_psi/(sig2_psi*sum(logV[-(T+1)]^2) + lamb)
psi <- rnorm(1, mean=mu_psi, sd=sqrt(sig2_psi))
alpha_lamb <- alpha_lamb + T/2
beta_lamb <- 1/2*sum((logV[-1] - phi - psi*logV[-(T+1)])^2) + beta_lamb
lamb <- rinvgamma(1, shape=alpha_lamb, rate=beta_lamb)
print(paste(mu_phi, mu_psi, beta_lamb/(alpha_lamb + 1)))
print(paste(phi, psi, lamb, i))
phi <- mu_phi; psi <- mu_psi; lamb <- beta_lamb/(alpha_lamb + 1)
logV_hist[i,] <- logV
phi_hist[i] <- phi
psi_hist[i] <- psi
lamb_hist[i] <- lamb
}
sqrt(0.00012761)
.12^2
logV
y
################################################################################
### Finite Difference ###
################################################################################
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
Sim_greek <- function(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta, seed=4002){
delta_t <- T / M
Milstein <- function(z, S_t, r, sigma){
(S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Euro_call <- function(S_t, K, r, sigma, T){
set.seed(seed)
for (m in 1:M){
z <- rnorm(n)
S_t <- Milstein(z, S_t, r, sigma)
}
mean(exp(-r*T) * pmax(S_t - K, 0))
}
Y <- Euro_call(S_0, K, r, sigma, T)
# Estimate delta using forward and central difference method
Y_S0_neg <- Euro_call(S_0-h_d, K, r, sigma, T)
Y_S0_pos <- Euro_call(S_0+h_d, K, r, sigma, T)
# Estimate vega using forward and central difference method
Y_sig_neg <- Euro_call(S_0, K, r, sigma-h_v, T)
Y_sig_pos <- Euro_call(S_0, K, r, sigma+h_v, T)
list(delta=list(forward=(Y_S0_pos - Y)/h_d,
central=(Y_S0_pos - Y_S0_neg)/(2*h_d)),
vega=list(forward=(Y_sig_pos - Y)/h_v,
central=(Y_sig_pos - Y_sig_neg)/(2*h_v)))
}
################################################################################
# Compute the exact delta and vega for theta=2 (BS)
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
h_delta <- seq(0.5, 0.05, by=-0.05); h_vega <- seq(0.05, 0.005, by=-0.005)
n <- 1e5; M <- 1e3
theta_lst <- c(2, 1, 1.8)
for (theta in theta_lst){
results_delta <- data.frame(h=h_delta, theta=theta,
delta_forward=0, delta_central=0)
results_vega <- data.frame(h=h_vega, theta=theta,
vega_forward=0, vega_central=0)
prog_bar <- txtProgressBar(min=0, max=length(h_delta), width=50, style=3)
for (i in 1:length(h_delta)) {
h_d <- h_delta[i]; h_v <- h_vega[i]
Euro_CEV <- Sim_greek(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta=theta)
results_delta$delta_forward[i] <- Euro_CEV$delta$forward
results_delta$delta_central[i] <- Euro_CEV$delta$central
results_vega$vega_forward[i] <- Euro_CEV$vega$forward
results_vega$vega_central[i] <- Euro_CEV$vega$central
setTxtProgressBar(prog_bar, i)
}
cat("\n")
print(results_delta)
print(results_vega)
}
h_delta <- seq(0.5, 0.05, by=-0.05); h_vega <- seq(0.05, 0.005, by=-0.005)
n <- 1e5; M <- 1e4
theta_lst <- c(2, 1, 1.8)
for (theta in theta_lst){
results_delta <- data.frame(h=h_delta, theta=theta,
delta_forward=0, delta_central=0)
results_vega <- data.frame(h=h_vega, theta=theta,
vega_forward=0, vega_central=0)
prog_bar <- txtProgressBar(min=0, max=length(h_delta), width=50, style=3)
for (i in 1:length(h_delta)) {
h_d <- h_delta[i]; h_v <- h_vega[i]
Euro_CEV <- Sim_greek(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta=theta)
results_delta$delta_forward[i] <- Euro_CEV$delta$forward
results_delta$delta_central[i] <- Euro_CEV$delta$central
results_vega$vega_forward[i] <- Euro_CEV$vega$forward
results_vega$vega_central[i] <- Euro_CEV$vega$central
setTxtProgressBar(prog_bar, i)
}
cat("\n")
print(results_delta)
print(results_vega)
}
################################################################################
### Finite Difference ###
################################################################################
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
Sim_greek <- function(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta, seed=4002){
delta_t <- T / M
Milstein <- function(z, S_t, r, sigma){
(S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Euro_call <- function(S_t, K, r, sigma, T){
set.seed(seed)
for (m in 1:M){
z <- rnorm(n)
S_t <- Milstein(z, S_t, r, sigma)
}
mean(exp(-r*T) * pmax(S_t - K, 0))
}
Y <- Euro_call(S_0, K, r, sigma, T)
# Estimate delta using forward and central difference method
Y_S0_neg <- Euro_call(S_0-h_d, K, r, sigma, T)
Y_S0_pos <- Euro_call(S_0+h_d, K, r, sigma, T)
# Estimate vega using forward and central difference method
Y_sig_neg <- Euro_call(S_0, K, r, sigma-h_v, T)
Y_sig_pos <- Euro_call(S_0, K, r, sigma+h_v, T)
list(delta=list(forward=(Y_S0_pos - Y)/h_d,
central=(Y_S0_pos - Y_S0_neg)/(2*h_d)),
vega=list(forward=(Y_sig_pos - Y)/h_v,
central=(Y_sig_pos - Y_sig_neg)/(2*h_v)))
}
################################################################################
# Compute the exact delta and vega for theta=2 (BS)
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
n <- 1e5; M <- 1e2
Euro_CEV <- Sim_greek(0.05, 0.005, n, M, S_0, K, r, sigma, T,
theta=2)
Euro_CEV
A <- c()
for (m in 1:M){
A <- cbind(A, rnorm(n))
}
dim(A)
Sim_greek <- function(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta, seed=4002){
delta_t <- T / M
Milstein <- function(z, S_t, r, sigma){
(S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Euro_call <- function(S_t, K, r, sigma, T){
set.seed(seed)
for (m in 1:M){
z <- A[,m]
S_t <- Milstein(z, S_t, r, sigma)
}
mean(exp(-r*T) * pmax(S_t - K, 0))
}
Y <- Euro_call(S_0, K, r, sigma, T)
# Estimate delta using forward and central difference method
Y_S0_neg <- Euro_call(S_0-h_d, K, r, sigma, T)
Y_S0_pos <- Euro_call(S_0+h_d, K, r, sigma, T)
# Estimate vega using forward and central difference method
Y_sig_neg <- Euro_call(S_0, K, r, sigma-h_v, T)
Y_sig_pos <- Euro_call(S_0, K, r, sigma+h_v, T)
list(delta=list(forward=(Y_S0_pos - Y)/h_d,
central=(Y_S0_pos - Y_S0_neg)/(2*h_d)),
vega=list(forward=(Y_sig_pos - Y)/h_v,
central=(Y_sig_pos - Y_sig_neg)/(2*h_v)))
}
################################################################################
# Compute the exact delta and vega for theta=2 (BS)
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
n <- 1e5; M <- 1e2
Euro_CEV <- Sim_greek(0.05, 0.005, n, M, S_0, K, r, sigma, T,
theta=2)
Euro_CEV
A <- c()
set.seed(4002)
for (m in 1:M){
A <- cbind(A, rnorm(n))
}
# Initialize variables
S_0 <- 10; K <- 8; r <- 0.05; sigma <- 0.3; T <- 1
Sim_greek <- function(h_d, h_v, n, M, S_0, K, r, sigma, T,
theta, seed=4002){
delta_t <- T / M
Milstein <- function(z, S_t, r, sigma){
(S_t*(1 + r*delta_t) + sigma*S_t^(theta/2)*sqrt(delta_t)*z +
sigma^2*theta/2*S_t^(theta-1)*delta_t/2*(z^2-1))
}
Euro_call <- function(S_t, K, r, sigma, T){
set.seed(seed)
for (m in 1:M){
z <- A[,m]
S_t <- Milstein(z, S_t, r, sigma)
}
mean(exp(-r*T) * pmax(S_t - K, 0))
}
Y <- Euro_call(S_0, K, r, sigma, T)
# Estimate delta using forward and central difference method
Y_S0_neg <- Euro_call(S_0-h_d, K, r, sigma, T)
Y_S0_pos <- Euro_call(S_0+h_d, K, r, sigma, T)
# Estimate vega using forward and central difference method
Y_sig_neg <- Euro_call(S_0, K, r, sigma-h_v, T)
Y_sig_pos <- Euro_call(S_0, K, r, sigma+h_v, T)
list(delta=list(forward=(Y_S0_pos - Y)/h_d,
central=(Y_S0_pos - Y_S0_neg)/(2*h_d)),
vega=list(forward=(Y_sig_pos - Y)/h_v,
central=(Y_sig_pos - Y_sig_neg)/(2*h_v)))
}
################################################################################
# Compute the exact delta and vega for theta=2 (BS)
d_plus <- (log(S_0/K) + (r+sigma^2/2)*T) / (sigma*sqrt(T))
(exact_delta <- pnorm(d_plus))
(exact_vega <- S_0 * sqrt(T) * dnorm(d_plus))
n <- 1e5; M <- 1e2
Euro_CEV <- Sim_greek(0.05, 0.005, n, M, S_0, K, r, sigma, T,
theta=2)
Euro_CEV
################################################################################
write.csv(A, "Asian.csv")
getwd()
#Set directory: Run this on source instead of Console!!
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
getwd()
################################################################################
write.csv(A, "Asian.csv")
